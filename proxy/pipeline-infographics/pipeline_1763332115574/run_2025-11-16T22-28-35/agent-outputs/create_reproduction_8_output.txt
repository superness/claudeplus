I'll create an automated reproduction script that uses the game's WebSocket automation framework to reproduce and verify the ship movement bug.

```javascript
#!/usr/bin/env node
// Bug Reproduction: Ship Not Moving After Setting Navigation Targets
// 
// Expected: Ship should move toward tapped/clicked locations using EVE-style physics
// Actual: Ship remains stationary despite navigation targets being set
// 
// This script:
// 1. Launches the game in Windows Chrome from WSL
// 2. Connects to WebSocket automation server on ws://localhost:8765
// 3. Gets initial ship state to verify starting position
// 4. Attempts to set navigation target programmatically
// 5. Waits for ship to move and checks position after delay
// 6. Verifies if ship position changed (bug = no movement)
// 7. Saves evidence of position data and movement results

const WebSocket = require('ws');
const { execSync } = require('child_process');
const fs = require('fs');

const WS_PORT = 8765;
const GAME_LOAD_TIMEOUT = 5000; // Increased to ensure game fully loads
const MOVEMENT_CHECK_DELAY = 3000; // Wait 3 seconds for ship to move

let ws;
let commandId = 1;
let commandQueue = [];
const evidence = {
  timestamp: new Date().toISOString(),
  bugDescription: "Ship not moving after setting navigation targets",
  commands: [],
  initialPosition: null,
  finalPosition: null,
  movementDetected: false
};

// Define test scenario to reproduce the movement bug
function defineScenario() {
  return [
    {
      command: 'getShipState',
      params: {},
      verify: (r) => r.position !== undefined && r.velocity !== undefined,
      desc: 'Get initial ship state and position',
      savePosition: 'initial'
    },
    {
      command: 'undock',
      params: {},
      verify: (r) => r.success || r.data?.docked === false,
      desc: 'Ensure ship is undocked (if docked)',
      optional: true // Don't fail if already undocked
    },
    {
      command: 'setNavigationTarget',
      params: {x: 5000, y: 5000, z: 0}, // Set target 5km away
      verify: (r) => r.success,
      desc: 'Set navigation target 5km away at (5000, 5000, 0)',
      fallback: 'navigateTo' // Try alternative command if this fails
    },
    {
      command: 'wait',
      params: {duration: MOVEMENT_CHECK_DELAY},
      verify: (r) => true,
      desc: `Wait ${MOVEMENT_CHECK_DELAY}ms for ship to move`,
      isWait: true
    },
    {
      command: 'getShipState',
      params: {},
      verify: (r) => r.position !== undefined,
      desc: 'Get final ship state after movement delay',
      savePosition: 'final'
    }
  ];
}

// Launch Chrome and connect to game automation
function runTest() {
  console.log('========================================');
  console.log('Ship Movement Bug Reproduction Script');
  console.log('========================================\n');
  
  console.log('[1/5] Launching game in Windows Chrome from WSL...');
  console.log('Command: /mnt/c/Program\\ Files/Google/Chrome/Application/chrome.exe file:///C:/github/superstarships/index.html\n');
  
  try {
    execSync('/mnt/c/Program\\ Files/Google/Chrome/Application/chrome.exe file:///C:/github/superstarships/index.html', {
      shell: true,
      stdio: 'ignore' // Suppress Chrome output
    });
  } catch (err) {
    console.error('Failed to launch Chrome:', err.message);
    saveEvidence('ERROR', {error: 'Failed to launch Chrome', details: err.message});
    process.exit(1);
  }
  
  console.log(`[2/5] Waiting ${GAME_LOAD_TIMEOUT}ms for game to initialize...\n`);
  
  setTimeout(() => {
    console.log('[3/5] Connecting to game automation server on ws://localhost:8765...');
    ws = new WebSocket(`ws://localhost:${WS_PORT}`);
    
    ws.on('open', () => {
      console.log('✓ Connected to game automation server!\n');
      console.log('[4/5] Executing test scenario...\n');
      commandQueue = defineScenario();
      executeNextCommand();
    });
    
    ws.on('message', handleGameResponse);
    
    ws.on('error', (err) => {
      console.error('✗ WebSocket Error:', err.message);
      evidence.commands.push({
        error: 'WebSocket connection failed',
        details: err.message,
        timestamp: new Date().toISOString()
      });
      saveEvidence('ERROR', evidence);
      process.exit(1);
    });
    
    ws.on('close', () => {
      console.log('\nWebSocket connection closed.');
    });
  }, GAME_LOAD_TIMEOUT);
}

function sendGameCommand(command, params) {
  const id = String(commandId++);
  ws.send(JSON.stringify({
    type: 'command',
    command: {id, command, params}
  }));
  return id;
}

function handleGameResponse(data) {
  const response = JSON.parse(data);
  const currentCmd = commandQueue[0];
  
  console.log(`Response [${response.id}] (${currentCmd?.command}):`, response.success ? '✓ Success' : '✗ Failed');
  
  // Save command and response to evidence
  evidence.commands.push({
    command: currentCmd?.command,
    params: currentCmd?.params,
    description: currentCmd?.desc,
    response: response,
    timestamp: new Date().toISOString()
  });
  
  // Save position data if this command marks a position checkpoint
  if (currentCmd?.savePosition) {
    if (currentCmd.savePosition === 'initial') {
      evidence.initialPosition = response.data?.position || null;
      console.log(`  Initial Position: x=${evidence.initialPosition?.x}, y=${evidence.initialPosition?.y}, z=${evidence.initialPosition?.z}`);
    } else if (currentCmd.savePosition === 'final') {
      evidence.finalPosition = response.data?.position || null;
      console.log(`  Final Position: x=${evidence.finalPosition?.x}, y=${evidence.finalPosition?.y}, z=${evidence.finalPosition?.z}`);
    }
  }
  
  // Handle command failure
  if (!response.success && !currentCmd?.optional) {
    console.error(`  Error: ${response.error || 'Unknown error'}`);
    
    // Try fallback command if available
    if (currentCmd?.fallback) {
      console.log(`  Attempting fallback command: ${currentCmd.fallback}`);
      currentCmd.command = currentCmd.fallback;
      sendGameCommand(currentCmd.command, currentCmd.params);
      return;
    }
    
    console.log('\n✗ Test failed due to command error');
    saveEvidence('FAILED', evidence);
    ws.close();
    process.exit(1);
    return;
  }
  
  // Run verification if provided
  if (currentCmd?.verify) {
    try {
      const passed = currentCmd.verify(response.data || response);
      console.log(`  Verification: ${passed ? '✓ Pass' : '✗ Fail'}`);
      
      if (!passed && !currentCmd?.optional) {
        console.log(`\n✗ Verification failed for: ${currentCmd.desc}`);
        saveEvidence('FAILED', evidence);
        ws.close();
        process.exit(1);
        return;
      }
    } catch (err) {
      console.log(`  Verification error: ${err.message}`);
    }
  }
  
  console.log(''); // Blank line for readability
  executeNextCommand();
}

function executeNextCommand() {
  if (commandQueue.length === 0) {
    console.log('[5/5] Analyzing results...\n');
    analyzeBugReproduction();
    return;
  }
  
  const cmd = commandQueue.shift();
  
  // Handle special wait command
  if (cmd.isWait) {
    console.log(`Executing: ${cmd.desc}`);
    setTimeout(() => {
      evidence.commands.push({
        command: 'wait',
        params: cmd.params,
        description: cmd.desc,
        timestamp: new Date().toISOString()
      });
      console.log('✓ Wait complete\n');
      executeNextCommand();
    }, cmd.params.duration);
    return;
  }
  
  console.log(`Executing: ${cmd.desc}`);
  sendGameCommand(cmd.command, cmd.params);
}

function analyzeBugReproduction() {
  console.log('========================================');
  console.log('Bug Reproduction Analysis');
  console.log('========================================\n');
  
  if (!evidence.initialPosition || !evidence.finalPosition) {
    console.log('✗ Could not obtain position data');
    saveEvidence('INCOMPLETE', evidence);
    ws.close();
    process.exit(1);
    return;
  }
  
  // Calculate distance moved
  const dx = evidence.finalPosition.x - evidence.initialPosition.x;
  const dy = evidence.finalPosition.y - evidence.initialPosition.y;
  const dz = evidence.finalPosition.z - evidence.initialPosition.z;
  const distanceMoved = Math.sqrt(dx*dx + dy*dy + dz*dz);
  
  evidence.distanceMoved = distanceMoved;
  evidence.movementDetected = distanceMoved > 10; // Threshold: 10 units = movement
  
  console.log('Initial Position:', evidence.initialPosition);
  console.log('Final Position:', evidence.finalPosition);
  console.log(`Distance Moved: ${distanceMoved.toFixed(2)} units`);
  console.log(`Movement Detected: ${evidence.movementDetected ? 'YES' : 'NO'}\n`);
  
  if (!evidence.movementDetected) {
    console.log('========================================');
    console.log('BUG REPRODUCED ✓');
    console.log('========================================');
    console.log('Ship did not move after setting navigation target.');
    console.log('Expected: Ship should move toward target (5000, 5000, 0)');
    console.log('Actual: Ship remained at initial position\n');
    saveEvidence('BUG_REPRODUCED', evidence);
  } else {
    console.log('========================================');
    console.log('BUG NOT REPRODUCED');
    console.log('========================================');
    console.log('Ship moved as expected. Bug may be fixed or not reproducible via automation.\n');
    saveEvidence('BUG_NOT_REPRODUCED', evidence);
  }
  
  ws.close();
  process.exit(evidence.movementDetected ? 0 : 1);
}

function saveEvidence(status, data) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `ship_movement_bug_evidence_${Date.now()}.json`;
  
  const finalEvidence = {
    ...data,
    status,
    finalTimestamp: new Date().toISOString(),
    conclusion: status === 'BUG_REPRODUCED' 
      ? 'Ship does not move when navigation target is set - movement system is broken'
      : status === 'BUG_NOT_REPRODUCED'
      ? 'Ship moved as expected - bug not reproduced'
      : 'Test incomplete or error occurred'
  };
  
  fs.writeFileSync(filename, JSON.stringify(finalEvidence, null, 2));
  console.log(`Evidence saved to: ${filename}`);
}

// Run the test
runTest();
```

**Output JSON Summary:**

```json
{
  "scriptPath": "/mnt/c/github/superstarships/tests/reproduce_ship_movement_bug.js",
  "scriptContent": "Full Node.js script included above",
  "commandSequence": [
    {
      "command": "getShipState",
      "expectedResult": "position and velocity data returned",
      "purpose": "Capture initial ship position before movement attempt"
    },
    {
      "command": "undock",
      "expectedResult": "success or already undocked",
      "purpose": "Ensure ship is not docked (docked ships cannot move)"
    },
    {
      "command": "setNavigationTarget",
      "expectedResult": "success: true",
      "purpose": "Set navigation target at (5000, 5000, 0) - 5km away",
      "params": {"x": 5000, "y": 5000, "z": 0}
    },
    {
      "command": "wait",
      "expectedResult": "3 second delay completes",
      "purpose": "Allow time for ship physics to move ship toward target"
    },
    {
      "command": "getShipState",
      "expectedResult": "position data returned showing movement",
      "purpose": "Capture final position to compare with initial position"
    }
  ],
  "evidenceFiles": [
    "ship_movement_bug_evidence_[timestamp].json"
  ],
  "expectedOutcome": "BUG REPRODUCED - Ship position does not change after navigation target is set, confirming the movement system is broken",
  "bugCriteria": "Distance moved < 10 units after 3 seconds with navigation target set 5km away",
  "executionInstructions": [
    "1. Save script as /mnt/c/github/superstarships/tests/reproduce_ship_movement_bug.js",
    "2. Ensure Node.js and 'ws' package are installed (npm install ws)",
    "3. Run from WSL: node reproduce_ship_movement_bug.js",
    "4. Script will launch Chrome with game, connect to WebSocket, execute commands",
    "5. Check console output for reproduction results",
    "6. Review evidence JSON file for detailed position data"
  ],
  "limitations": [
    "Requires 'setNavigationTarget' or 'navigateTo' command to be implemented in GameTestingInterface.js",
    "If command not available, script will fail with 'Unknown command' error",
    "May need to add navigation command to js/testing/GameTestingInterface.js first"
  ]
}
```

**DECISION: script_ready**