# Implementation Plan: Persistent Ship Fitting with Event-Driven Save

## Architecture

### New Classes/Modules
No new classes needed - this feature extends existing `ShipFittingUI.js` functionality.

### Modified Classes

#### 1. `ShipFittingUI` (js/ui/ShipFittingUI.js)
**New Methods:**
- `saveFittingState()` - Serializes current fitting to localStorage
- `loadFittingState()` - Deserializes and restores fitting from localStorage
- `_serializeFitting()` - Helper to convert fitting data to JSON-safe format
- `_deserializeFitting(data)` - Helper to parse and validate saved data
- `_validateRestoredModule(moduleData)` - Validates module exists in game data

**Modified Methods:**
- `fitModule(module, slotType, slotIndex)` - Add `saveFittingState()` call at end
- `removeModule(slotType, slotIndex)` - Add `saveFittingState()` call at end
- `initialize()` or constructor - Add `loadFittingState()` call during initialization

**New Properties:**
- `STORAGE_KEY = 'superstarships_ship_fitting'` - localStorage key constant
- `SAVE_VERSION = 1` - Save format version for future migration

### Integration Points

#### With SpaceshipSimulator
- `SpaceshipSimulator.js` initialization must ensure `ShipFittingUI` is created before calling `loadFittingState()`
- May need to expose current ship type/ID via `simulator.currentShip.type`

#### With Inventory System
- Must access inventory to remove fitted modules during restoration
- Need to verify module exists in inventory before fitting during load
- May need to call inventory update methods after restoration

#### With Ship Entity
- Need stable ship identifier (type or ID) to associate fittings with ships
- Ship class should expose `ship.type` or `ship.id` property

### Design Patterns

1. **Immediate Persistence Pattern**: Save on every state change (fit/remove action)
2. **Try-Catch Wrapper**: All localStorage operations wrapped in error handling
3. **Graceful Degradation**: Feature fails silently if localStorage unavailable
4. **Data Validation**: Validate all restored data before applying to game state

---

## File Structure

### Files to Create
None - all changes are modifications to existing files.

### Files to Modify

#### Primary File
```
/mnt/c/github/superstarships/js/ui/ShipFittingUI.js
```
**Changes:**
- Add 5 new methods (save, load, serialize, deserialize, validate)
- Modify 2 existing methods (fitModule, removeModule)
- Add 2 class constants (STORAGE_KEY, SAVE_VERSION)
- Estimated lines added: ~200-250 lines

#### Secondary Files

```
/mnt/c/github/superstarships/js/SpaceshipSimulator.js
```
**Changes:**
- Ensure ShipFittingUI initialization happens before loadFittingState() call
- May need to call `this.shipFittingUI.loadFittingState()` after initialization
- Estimated lines added: ~5-10 lines

---

## Implementation Steps

### Step 1: Add localStorage Utility Methods (30 min)
**Task:** Implement safe localStorage read/write helpers in ShipFittingUI

**Details:**
- Add `_saveToStorage(key, data)` method with try-catch
- Add `_loadFromStorage(key)` method with try-catch and JSON.parse
- Add `_clearStorage(key)` method for error recovery
- Handle quota exceeded errors
- Handle JSON parse errors
- Log warnings on failures (not errors - fail silently)

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** None

**Validation:**
```javascript
// Test in console
simulator.shipFittingUI._saveToStorage('test', {foo: 'bar'});
console.log(simulator.shipFittingUI._loadFromStorage('test')); // {foo: 'bar'}
```

---

### Step 2: Implement Fitting State Serialization (45 min)
**Task:** Add `_serializeFitting()` method to convert current fitting to JSON

**Details:**
- Iterate through all slot types (high, mid, low, rig)
- For each fitted module, extract:
  - `moduleId` (unique identifier from module data)
  - `moduleName` (for human readability)
  - `slotType` (high/mid/low/rig)
  - `slotIndex` (position within slot type)
  - `moduleData` (full module stats for restoration)
- Get current ship type: `this.simulator.currentShip.type`
- Build JSON structure:
```javascript
{
  shipType: "Atron",
  fittedModules: [ /* array of module objects */ ],
  timestamp: Date.now(),
  version: this.SAVE_VERSION
}
```
- Return serializable object (not JSON string - helpers handle that)

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** Step 1

**Validation:**
```javascript
// Fit some modules, then test
const state = simulator.shipFittingUI._serializeFitting();
console.log(JSON.stringify(state, null, 2)); // Valid JSON
console.assert(state.shipType === "Atron");
console.assert(Array.isArray(state.fittedModules));
```

---

### Step 3: Implement Fitting State Deserialization (60 min)
**Task:** Add `_deserializeFitting(data)` and `_validateRestoredModule(moduleData)` methods

**Details:**

**`_validateRestoredModule(moduleData)`:**
- Check if module exists in game's module database
- Verify required fields present: `moduleId`, `slotType`, `slotIndex`
- Return true/false
- Log warning if module not found (skip gracefully)

**`_deserializeFitting(data)`:**
- Validate data structure:
  - Has `shipType` field
  - Has `fittedModules` array
  - Has `version` field
- Check ship type matches current ship (if mismatch, log and return false)
- Filter modules through `_validateRestoredModule()`
- Return validated module array or null on failure

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** Step 2

**Validation:**
```javascript
// Test with mock data
const mockData = {
  shipType: "Atron",
  fittedModules: [{moduleId: "mining_laser_i", slotType: "high", slotIndex: 0}],
  version: 1
};
const modules = simulator.shipFittingUI._deserializeFitting(mockData);
console.assert(modules !== null);
console.assert(modules.length === 1);
```

---

### Step 4: Implement saveFittingState() Method (30 min)
**Task:** Add public `saveFittingState()` method

**Details:**
- Call `_serializeFitting()` to get current state
- Call `_saveToStorage(this.STORAGE_KEY, state)`
- Catch and log any errors (fail silently)
- Optional: Log success to console in debug mode
- Keep method simple - all logic in helpers

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** Steps 1-2

**Validation:**
```javascript
// Fit module, save manually
simulator.shipFittingUI.saveFittingState();
// Check localStorage
const saved = localStorage.getItem('superstarships_ship_fitting');
console.log(JSON.parse(saved)); // Should show fitted modules
```

---

### Step 5: Implement loadFittingState() Method (90 min)
**Task:** Add public `loadFittingState()` method to restore fitting on load

**Details:**
- Call `_loadFromStorage(this.STORAGE_KEY)` to get saved data
- If no data, return early (first load case)
- Call `_deserializeFitting(data)` to validate
- If validation fails, clear corrupted data and return
- For each validated module:
  1. Check if module exists in player inventory (or create if admin mode)
  2. Call existing `fitModule(module, slotType, slotIndex)` method
     - **IMPORTANT:** Temporarily disable save during restoration to avoid re-saving on every fit
     - Use flag: `this._isRestoring = true` before loop, `false` after
  3. Remove module from inventory (if inventory system tracks this)
  4. Update UI to show fitted module
- After all modules restored:
  - Recalculate CPU/Power usage
  - Update fitting UI display
  - Log restoration summary (X modules restored)

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** Steps 1-4

**Validation:**
```javascript
// Save a fitting, reload page, check console
// Should see: "Restored 3 modules from saved fitting"
// Fitting UI should show modules immediately when opened
```

---

### Step 6: Hook Save Calls into Fit/Remove Actions (20 min)
**Task:** Add `saveFittingState()` calls to existing action handlers

**Details:**

**In `fitModule(module, slotType, slotIndex)` method:**
- Find the end of the method (after module is fitted successfully)
- Add:
```javascript
// Auto-save fitting state (unless restoring)
if (!this._isRestoring) {
  this.saveFittingState();
}
```

**In `removeModule(slotType, slotIndex)` method:**
- Find the end of the method (after module is removed successfully)
- Add same save call:
```javascript
// Auto-save fitting state
if (!this._isRestoring) {
  this.saveFittingState();
}
```

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** Steps 4-5

**Validation:**
```javascript
// Fit module via UI → check localStorage immediately
simulator.shipFittingUI.fitModule(module, 'high', 0);
// localStorage should update within milliseconds
const saved = JSON.parse(localStorage.getItem('superstarships_ship_fitting'));
console.assert(saved.fittedModules.length > 0);
```

---

### Step 7: Hook Restoration into Game Initialization (30 min)
**Task:** Call `loadFittingState()` during game startup

**Details:**

**In `SpaceshipSimulator.js`:**
- Find where `ShipFittingUI` is initialized
- After initialization, add:
```javascript
// Restore saved ship fitting from previous session
if (this.shipFittingUI && this.shipFittingUI.loadFittingState) {
  this.shipFittingUI.loadFittingState();
}
```
- Ensure this happens AFTER:
  - Ship is created/initialized
  - Inventory is loaded
  - ShipFittingUI is fully initialized
- Ensure this happens BEFORE:
  - UI is shown to player (fitting should be pre-loaded)

**Files:** `js/SpaceshipSimulator.js`

**Dependencies:** Steps 1-6

**Validation:**
```javascript
// Fit modules, reload page
// Open fitting UI → modules should already be fitted
// Check console for "Restored X modules" message
```

---

### Step 8: Add Error Handling and Edge Cases (45 min)
**Task:** Implement robust error handling for all edge cases

**Details:**

**localStorage Quota Exceeded:**
- Wrap `localStorage.setItem()` in try-catch
- Catch `QuotaExceededError`
- Log warning: "Could not save fitting: storage quota exceeded"
- Continue without persistence

**Corrupted JSON:**
- Wrap `JSON.parse()` in try-catch
- Catch `SyntaxError`
- Clear corrupted data: `localStorage.removeItem(key)`
- Log warning: "Corrupted save data cleared"
- Initialize with empty fitting

**Missing Modules:**
- In `_validateRestoredModule()`, check module database
- If module not found:
  - Log warning: "Module 'X' no longer exists, skipping"
  - Return false (skip that module)
  - Continue with other modules

**Ship Type Mismatch:**
- In `_deserializeFitting()`, compare `data.shipType` to `simulator.currentShip.type`
- If mismatch:
  - Log info: "Saved fitting for different ship type, skipping restoration"
  - Return null (don't restore)

**Browser Privacy Mode:**
- If `localStorage` is `undefined` or read-only:
  - Detect with try-catch on `localStorage.setItem()`
  - Set flag: `this._persistenceDisabled = true`
  - Log info: "Persistence disabled (private browsing mode?)"
  - Continue without persistence

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** All previous steps

**Validation:**
```javascript
// Manually corrupt localStorage
localStorage.setItem('superstarships_ship_fitting', '{invalid json');
// Reload page → should not crash, should clear corrupted data

// Delete saved module from game data
// Reload page → should skip that module, restore others
```

---

### Step 9: Add Console Logging and Debug Info (20 min)
**Task:** Add useful logging for debugging and validation

**Details:**
- `saveFittingState()`: Log "Saved fitting state: X modules"
- `loadFittingState()`: Log "Restored X modules from saved fitting"
- `loadFittingState()`: Log "No saved fitting found (first load)"
- Error handlers: Log warnings with context
- Consider adding debug flag to enable verbose logging

**Files:** `js/ui/ShipFittingUI.js`

**Dependencies:** Steps 1-8

**Validation:**
```javascript
// Open console, perform actions
// Should see clear log messages:
// "Saved fitting state: 3 modules"
// Reload page:
// "Restored 3 modules from saved fitting"
```

---

### Step 10: Automated Testing with Browser Automation (60 min)
**Task:** Run test suite using existing `test_ship_fitting_persistence.js`

**Details:**
- Execute test script: `node test_ship_fitting_persistence.js`
- Script will:
  1. Launch Chrome with game via ChromeManager
  2. Execute 8 test cases (39 steps):
     - TC-001: Single module persistence
     - TC-002: Module removal persistence
     - TC-003: Multiple modules persistence
     - TC-004: Corrupted localStorage handling
     - TC-005: Missing localStorage handling
     - TC-006: Synchronous save on fit
     - TC-007: Synchronous save on remove
     - TC-008: Slot position preservation
  3. Collect console logs via ChromeManager
  4. Generate evidence file with results
  5. Exit with code 0 (pass) or 1 (fail)
- Review evidence file for any failures
- Fix any issues found
- Re-run tests until all pass

**Files:** Run `test_ship_fitting_persistence.js` (already created in plan_tests stage)

**Dependencies:** Steps 1-9 complete

**Validation:**
```bash
node test_ship_fitting_persistence.js
# Expected output:
# ✓ TC-001: PASS
# ✓ TC-002: PASS
# ... (all 8 test cases pass)
# Exit code: 0
```

---

### Step 11: Manual Testing and Polish (30 min)
**Task:** Perform manual testing and UI polish

**Manual Test Checklist:**
- [ ] Fit module → Reload page → Module still fitted
- [ ] Remove module → Reload page → Module removed
- [ ] Fit 5 modules → Reload page → All 5 restored
- [ ] Clear localStorage → Reload → No crash, empty fitting
- [ ] Manually corrupt JSON → Reload → Graceful handling
- [ ] Check console logs for clear messages
- [ ] Verify no console errors during normal operation
- [ ] Test with different ship types (if multiple ships available)

**Polish:**
- Review log messages for clarity
- Ensure no redundant console output
- Verify UI updates smoothly after restoration
- Test performance (restoration should be < 500ms)

**Files:** User testing in browser

**Dependencies:** Steps 1-10 complete

---

## Technical Considerations

### Performance

**localStorage Write Performance:**
- `localStorage.setItem()` is synchronous and blocks JavaScript execution
- Ship fitting state is small (~1-10 KB JSON)
- Write time: < 5ms on modern browsers
- **Impact:** Negligible - acceptable to call on every fit/remove action

**Restoration Performance:**
- Must restore fitting before UI is shown
- Restoration involves:
  - JSON parse: < 1ms
  - Module validation: < 10ms (depends on module count)
  - Fitting modules: < 50ms (DOM updates)
- **Target:** < 500ms total restoration time
- **Optimization:** Use `requestAnimationFrame` if restoration causes jank

**Memory Usage:**
- localStorage quota: 5-10 MB per domain
- Ship fitting state: < 10 KB per save
- **Impact:** Negligible memory footprint

### Browser Compatibility

**localStorage Support:**
- Supported in all modern browsers (Chrome, Firefox, Edge, Safari)
- IE11+ support (if needed)
- **Fallback:** Detect unavailability and disable persistence gracefully

**JSON API:**
- `JSON.stringify()` and `JSON.parse()` widely supported
- Handle circular references (should not occur with fitting data)

**ES6 Features Used:**
- Template literals
- Arrow functions
- `const`/`let`
- **Compatibility:** ES6 supported in all target browsers (per project requirements)

### Security Considerations

**localStorage Security:**
- Data stored unencrypted (acceptable for game state)
- No sensitive user data stored (no passwords, emails, etc.)
- XSS risk: If attacker can execute JS, they can read localStorage (not a concern for single-player game)

**Data Validation:**
- Always validate restored data before applying to game state
- Prevent code injection via module names (use strict JSON parsing)
- Sanitize any user-generated content (not applicable here)

### Code Reusability

**Utility Methods:**
- `_saveToStorage()` and `_loadFromStorage()` can be extracted to a shared utility class
- Could be reused for other persistence features (player settings, game progress)
- Consider creating `js/utils/StorageManager.js` in future refactoring

**Serialization Pattern:**
- `_serializeFitting()` / `_deserializeFitting()` pattern can be applied to other game systems
- Consider generalizing to `SerializableGameState` interface in future

---

## Risks and Mitigations

### Risk 1: Inventory Duplication
**Risk:** Restored modules might duplicate inventory items if inventory system not properly synced

**Mitigation:**
- During restoration, explicitly remove fitted modules from inventory
- Validate inventory has module before fitting during load
- Add inventory transaction logging for debugging

### Risk 2: Constraint Violations After Game Balance Changes
**Risk:** Restored fitting might exceed CPU/Power limits if module stats changed between sessions

**Mitigation:**
- Restore fitting regardless of constraints (let player see the issue)
- Add warning log: "Restored fitting exceeds CPU/Power limits"
- Alternative: Unfit violating modules automatically (more complex)

### Risk 3: Ship Type Changes
**Risk:** Player switches ships but saved fitting is for old ship type

**Mitigation:**
- Store ship type in save data
- Only restore if ship type matches current ship
- Future enhancement: Store fittings per ship type (out of scope for v1)

### Risk 4: localStorage Disabled in Browser Settings
**Risk:** User has disabled localStorage in browser settings

**Mitigation:**
- Detect with try-catch on first `setItem()` call
- Set `_persistenceDisabled` flag
- Log info message, continue without persistence
- Game remains fully playable

### Risk 5: Race Conditions During Page Load
**Risk:** Fitting restoration happens before inventory/ship is fully initialized

**Mitigation:**
- Ensure `loadFittingState()` is called AFTER all dependencies initialized
- Add initialization state checks in `loadFittingState()`
- Log error and abort restoration if dependencies not ready

---

## Testing & Validation Strategy

### Automated Testing (Primary)

**Browser Automation via ChromeManager:**
- Test script: `test_ship_fitting_persistence.js` (created in plan_tests stage)
- **8 Test Cases** covering:
  - Core persistence (fit, remove, multiple modules)
  - Error handling (corrupted data, missing data)
  - Synchronous save validation (immediate localStorage update)
  - Data integrity (slot positions preserved)
- **39 Test Steps** executed via WebSocket automation
- **Console Log Monitoring:** ChromeManager captures all console output
- **Evidence Collection:** Results saved to timestamped JSON file
- **Exit Code Validation:** Script exits 0 (all pass) or 1 (any fail)

**Test Execution:**
```bash
node test_ship_fitting_persistence.js
```

**Expected Output:**
```
=== Superstarships - Ship Fitting Persistence Test ===
Initializing ChromeManager...
Launching Chrome...
Connecting to automation endpoint...
Executing test scenario (39 steps)...

TC-001: Single module persistence across reload
  ✓ Step 1: PASS
  ✓ Step 2: PASS
  ...
  ✓ TC-001: PASS

TC-002: Module removal persistence across reload
  ...

=== Test Summary ===
Total Test Cases: 8
Passed: 8
Failed: 0
Console Errors: 0
Evidence File: test-results-20250118-143052.json
Exit Code: 0
```

### Manual Testing (Secondary)

**User Acceptance Testing:**
- Follow manual test checklist in Step 11
- Verify user experience (no loading delays, smooth restoration)
- Test edge cases not covered by automation

### Console Log Verification

**During Automated Tests:**
- ChromeManager captures all console logs
- Check evidence file for unexpected errors/warnings
- Validate expected log messages appear:
  - "Saved fitting state: X modules"
  - "Restored X modules from saved fitting"

**During Manual Tests:**
- Open DevTools console
- Verify clean console (no errors)
- Check log messages for clarity

---

## Success Criteria

### Functional Requirements Met
✓ Immediate save on fit action (validated by TC-006)
✓ Immediate save on remove action (validated by TC-007)
✓ State restoration on page load (validated by TC-001, TC-002, TC-003)
✓ Slot position preservation (validated by TC-008)
✓ Graceful error handling (validated by TC-004, TC-005)

### Performance Requirements Met
✓ Restoration time < 500ms (measured in automated tests)
✓ Save time < 50ms (synchronous localStorage.setItem)
✓ No UI jank during restoration (manual testing)

### Quality Requirements Met
✓ All automated tests pass (8/8 test cases)
✓ No console errors during normal operation
✓ Clean, readable code with JSDoc comments
✓ Proper error handling for all edge cases

### User Experience Requirements Met
✓ Transparent operation (no user-facing save/load buttons)
✓ Immediate visual feedback (fitted modules appear instantly on load)
✓ No data loss (100% save success rate)
✓ Game playable even if persistence disabled

---

## Documentation Requirements

### Code Documentation
- Add JSDoc comments to all new methods:
  - `@description` - What the method does
  - `@returns` - Return type and meaning
  - `@throws` - Potential errors (none - all errors caught)
  - `@example` - Usage example for public methods

**Example:**
```javascript
/**
 * Saves the current ship fitting state to localStorage.
 * Called automatically after every fit/remove action.
 * Fails silently if localStorage unavailable.
 * 
 * @returns {boolean} True if save successful, false otherwise
 * 
 * @example
 * this.saveFittingState(); // Auto-saves current fitting
 */
saveFittingState() {
  // ...
}
```

### Project Documentation Updates

**Update `CLAUDE.md`:**
- Add section under "Game Features and Systems" → "Persistent Ship Fitting"
- Document localStorage schema
- Note save-on-action approach
- Link to test script

**Example Addition:**
```markdown
#### Persistent Ship Fitting
- **Save Strategy**: Event-driven save on every fit/remove action
- **Storage**: Client-side localStorage (key: `superstarships_ship_fitting`)
- **Restoration**: Automatic on page load during game initialization
- **Error Handling**: Graceful degradation if localStorage unavailable
- **Testing**: Automated test suite at `test_ship_fitting_persistence.js`
```

---

## Implementation Timeline

**Total Estimated Time: 7-8 hours**

| Step | Task | Time | Cumulative |
|------|------|------|------------|
| 1 | localStorage utilities | 30 min | 0.5h |
| 2 | Serialization | 45 min | 1.25h |
| 3 | Deserialization | 60 min | 2.25h |
| 4 | saveFittingState() | 30 min | 2.75h |
| 5 | loadFittingState() | 90 min | 4.25h |
| 6 | Hook save calls | 20 min | 4.5h |
| 7 | Hook restoration | 30 min | 5h |
| 8 | Error handling | 45 min | 5.75h |
| 9 | Logging | 20 min | 6h |
| 10 | Automated testing | 60 min | 7h |
| 11 | Manual testing | 30 min | 7.5h |

**Critical Path:** Steps 1→2→3→4→5→6→7 must be done sequentially
**Parallelizable:** Steps 8-9 can be done alongside 1-7
**Buffer Time:** Add 30-60 min for unexpected issues

---

## Next Steps After Implementation

### Immediate Follow-Up
1. Monitor player feedback for any restoration issues
2. Check browser console logs for unexpected errors
3. Measure actual restoration performance in production

### Future Enhancements (Out of Scope for V1)
1. **Multiple Saved Fittings:** Allow players to save/load multiple fitting loadouts per ship
2. **Fitting Templates:** Share/import fitting templates from other players
3. **Ship-Specific Storage:** Store separate fittings for each owned ship
4. **Cloud Sync:** Optional cloud storage for cross-device synchronization
5. **Fitting History:** Undo/redo functionality for fitting changes
6. **Export/Import:** Export fittings to JSON file for backup/sharing

---

DECISION: implementation_plan_ready