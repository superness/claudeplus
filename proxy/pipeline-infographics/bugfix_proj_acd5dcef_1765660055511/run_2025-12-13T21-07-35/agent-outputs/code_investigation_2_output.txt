**FOUND IT!** The bug is in the `restoreState` function!

Look at lines 1029-1031:
```javascript
for (const p of this.pieceSystem.pieces) {
    if (p.isKing === state.pieceIsKing ||
        (p.x !== state.pieceX || p.y !== state.pieceY)) {
```

This condition is WRONG. It says:
- `p.isKing === state.pieceIsKing` - finds pieces with SAME king status OR
- `(p.x !== state.pieceX || p.y !== state.pieceY)` - pieces NOT at the saved position

This is using `||` (OR) when it should probably use `&&` (AND) or have different logic entirely. The condition will match almost EVERY piece because most pieces either have the same king status OR are not at the saved position.

The intended logic should find the specific piece that was moved during simulation - which should be at the NEW position (not the old position) and needs to be restored to the old position. 

But wait, let me re-read this more carefully...

The logic seems very broken:
1. `p.isKing === state.pieceIsKing` - This matches ANY piece with the same king status as the saved piece (either all kings or all non-kings)
2. `||` means this OR the next condition
3. `(p.x !== state.pieceX || p.y !== state.pieceY)` - This matches ANY piece NOT at the original position

So essentially this matches almost every single piece in the game! The `break` statement exits after the first match, but that first match could be ANY piece.

The effect: During minimax evaluation, when `restoreState` is called, it's moving the WRONG pieces around. This corrupts the board state during AI evaluation, but since evaluation happens in `chooseBestMove` BEFORE the actual AI move is executed... wait, let me trace this more carefully.

Actually wait - in `chooseBestMove`:
```javascript
const state = this.saveState(move);
this.applyMove(move);
moveScore += this.minimax(depth - 1, false, -Infinity, Infinity) * 0.5;
this.restoreState(state);
```

After `restoreState` is called with the broken logic, the board state is corrupted. Then the loop continues to evaluate the next move, but the board state is now wrong. This cumulative corruption could explain why "many pieces change place"!

The AI evaluates multiple moves, and each time `restoreState` moves the wrong piece back. After evaluating all moves, the board state has been scrambled by all the botched restorations. Then when the AI finally executes its chosen move, it's executing on a corrupted board state.

**Investigation Summary**:
The bug is in the AI's `restoreState` function used during minimax move evaluation. The logic for finding which piece to restore is fundamentally broken - it matches almost any piece instead of the specific piece that was moved during simulation.

**Root Cause**:
File: `client/game.js`
Line(s): 1029-1031
Issue: The condition `if (p.isKing === state.pieceIsKing || (p.x !== state.pieceX || p.y !== state.pieceY))` uses incorrect boolean logic that matches almost every piece instead of the specific moved piece.
Why: During AI minimax evaluation, the board state is simulated with `applyMove` and then supposedly restored with `restoreState`. But `restoreState` incorrectly identifies which piece was moved, resulting in random pieces being repositioned. After multiple evaluation iterations, the board state becomes corrupted. When the player makes their first move and triggers AI evaluation, this corruption manifests as "many pieces moving".

**Fix Strategy**:
The `restoreState` function needs to be rewritten to correctly identify the piece that was moved during simulation. The simplest fix would be:
1. Store a reference to the actual piece object in `saveState` (not just its position)
2. In `restoreState`, use that reference directly instead of searching

Alternatively, fix the logic to find the piece at the NEW position (after `applyMove`) by checking for the piece at the simulated destination coordinates, which would be `move.toX, move.toY`.

**Risks/Considerations**:
- The fix must ensure the piece reference remains valid during recursive minimax calls
- Need to verify captured pieces are also properly restored to the board (they're removed during `applyMove`)
- The captured piece restoration at lines 1044-1045 may also need verification since it relies on finding the piece in the `pieces` array

DECISION: root_cause_found