<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- NO meta refresh - viewer handles refreshing via iframe reload to preserve toggle state -->
  <title>Pipeline: Intelligent Mining Infrastructure Setup</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      color: #333;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .header {
      background: white;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
    }
    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    .metric {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }
    .metric-label {
      font-size: 0.85em;
      color: #6c757d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .metric-value {
      font-size: 1.8em;
      font-weight: bold;
      color: #333;
      margin-top: 5px;
    }
    .timeline {
      position: relative;
      padding-left: 40px;
      margin-top: 20px;
    }
    .timeline::before {
      content: '';
      position: absolute;
      left: 20px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
    }
    .stage {
      background: white;
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 20px;
      position: relative;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      transition: transform 0.2s;
    }
    .stage:hover {
      transform: translateX(5px);
    }
    .stage::before {
      content: '';
      position: absolute;
      left: -28px;
      top: 30px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 3px solid white;
      box-shadow: 0 0 0 2px #667eea;
    }
    .stage.running::before { background: #ffc107; box-shadow: 0 0 0 2px #ffc107, 0 0 20px #ffc107; }
    .stage.completed::before { background: #28a745; box-shadow: 0 0 0 2px #28a745; }
    .stage.error::before { background: #dc3545; box-shadow: 0 0 0 2px #dc3545; }
    .stage-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 15px;
    }
    .stage-title {
      font-size: 1.4em;
      font-weight: bold;
      color: #333;
    }
    .stage-badge {
      display: inline-block;
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 0.75em;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .badge-running { background: #fff3cd; color: #856404; }
    .badge-completed { background: #d4edda; color: #155724; }
    .badge-error { background: #f8d7da; color: #721c24; }
    .stage-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin: 15px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .meta-item {
      font-size: 0.9em;
    }
    .meta-label {
      color: #6c757d;
      font-weight: 500;
    }
    .meta-value {
      color: #333;
      font-weight: bold;
      margin-left: 5px;
    }
    .stage-output {
      margin-top: 15px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      max-height: 500px;
      overflow-y: auto;
    }
    .stage-output pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.9em;
      line-height: 1.6;
      color: #333;
    }
    .error-box {
      background: #fff5f5;
      border: 2px solid #fc8181;
      border-radius: 8px;
      padding: 20px;
      margin-top: 15px;
    }
    .error-title {
      color: #c53030;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .error-stack {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.85em;
      color: #742a2a;
      background: white;
      padding: 15px;
      border-radius: 6px;
      overflow-x: auto;
    }
    .routing-info {
      background: #e7f3ff;
      border-left: 4px solid #2196F3;
      padding: 15px;
      margin-top: 15px;
      border-radius: 6px;
    }
    .routing-decision {
      font-weight: bold;
      color: #1976D2;
      margin-bottom: 5px;
    }
    .completion-banner {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 12px;
      text-align: center;
      margin-bottom: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    .completion-banner h2 {
      font-size: 2em;
      margin-bottom: 10px;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .running-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #ffc107;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 1.5s infinite;
    }
    .ai-summary {
      background: white;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      border-left: 6px solid #667eea;
    }
    .ai-summary h2 {
      font-size: 1.8em;
      margin-bottom: 15px;
      color: #333;
    }
    .summary-narrative {
      font-size: 1.1em;
      line-height: 1.8;
      color: #555;
    }
    .collapsible {
      cursor: pointer;
      padding: 12px;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      margin: 10px 0;
      font-weight: bold;
      color: #495057;
      transition: background 0.2s;
    }
    .collapsible:hover {
      background: #e9ecef;
    }
    .collapsible::before {
      content: '‚ñ∂ ';
      display: inline-block;
      transition: transform 0.2s;
    }
    .collapsible.active::before {
      transform: rotate(90deg);
    }
    .collapsible-content {
      display: none;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 6px;
      margin-top: 5px;
      border-left: 4px solid #667eea;
    }
    .collapsible-content.active {
      display: block;
    }
    .prompt-section {
      background: #fff5e6;
      border-left: 4px solid #ff9800;
      padding: 15px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .output-section {
      background: #e8f5e9;
      border-left: 4px solid #4caf50;
      padding: 15px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .section-label {
      font-weight: bold;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      color: #555;
    }
    .char-count {
      font-size: 0.85em;
      color: #6c757d;
      font-style: italic;
    }
    pre.code-content {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
      line-height: 1.6;
      color: #333;
      background: white;
      padding: 15px;
      border-radius: 6px;
      max-height: none;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    

    

    <div class="header">
      <h1><span class="running-indicator"></span>Intelligent Mining Infrastructure Setup</h1>
      <p style="color: #6c757d; font-size: 1.1em; margin-top: 5px;">Pipeline ID: pipeline_1763865894912</p>

      <div class="metrics">
        <div class="metric">
          <div class="metric-label">Elapsed Time</div>
          <div class="metric-value">713.4s</div>
        </div>
        <div class="metric">
          <div class="metric-label">Stages Completed</div>
          <div class="metric-value">2/3</div>
        </div>
        <div class="metric">
          <div class="metric-label">Errors</div>
          <div class="metric-value" style="color: #28a745">0</div>
        </div>
        <div class="metric">
          <div class="metric-label">Status</div>
          <div class="metric-value" style="font-size: 1.2em;">‚ö° Running</div>
        </div>
      </div>
    </div>

    <div class="timeline">
      
    <div class="stage completed">
      <div class="stage-header">
        <div>
          <div class="stage-title">Infrastructure Orchestrator</div>
          <div style="color: #6c757d; font-size: 0.9em; margin-top: 5px;">Analyzes infrastructure needs, delegates tasks to specialized agents, adapts to failures, learns from outcomes</div>
        </div>
        <span class="stage-badge badge-completed">completed</span>
      </div>

      <div class="stage-meta">
        <div class="meta-item">
          <span class="meta-label">Agent:</span>
          <span class="meta-value">infrastructure_orchestrator</span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Type:</span>
          <span class="meta-value"></span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Duration:</span>
          <span class="meta-value">108.5s</span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Execution #:</span>
          <span class="meta-value">1</span>
        </div>
        
        <div class="meta-item">
          <span class="meta-label">Prompt Size:</span>
          <span class="meta-value">20,904 chars</span>
        </div>
        
        
        <div class="meta-item">
          <span class="meta-label">Output Size:</span>
          <span class="meta-value">3,358 chars</span>
        </div>
        
      </div>

      
      <div class="prompt-section">
        <div class="section-label">üì• AGENT PROMPT <span class="char-count">(20,904 characters)</span></div>
        <button class="collapsible" data-target="prompt_orchestrate_1">Click to expand prompt from infrastructure_orchestrator</button>
        <div class="collapsible-content" id="prompt_orchestrate_1">
          <pre class="code-content">You are the Infrastructure Orchestrator - the intelligent brain that coordinates mining infrastructure setup through dynamic delegation to specialized agents.

## Your Core Role

Unlike traditional scripted pipelines that follow A‚ÜíB‚ÜíC‚ÜíD rigidly, you are an **intelligent decision-maker** that:

1. **Analyzes current infrastructure state** - What exists? What&#039;s missing? What&#039;s broken?
2. **Plans next actions dynamically** - What needs to be done next? Who should do it?
3. **Delegates to specialized agents** - Route tasks to the right agent for the job
4. **Adapts to outcomes** - Success? Failure? Partial? Decide next step accordingly
5. **Learns from failures** - Pattern detected? Adjust strategy
6. **Makes escalation decisions** - Can recover? Or need human intervention?

## How You Think

### Initial Invocation (First Call)

When you&#039;re first invoked, you receive the user&#039;s prompt describing what infrastructure is needed. Your thought process:

```
1. ANALYZE: What does the user want?
   - Full infrastructure setup from scratch?
   - Just fix a specific component?
   - Validate existing infrastructure?
   - Recover from a failure?

2. ASSESS CURRENT STATE: What exists already?
   - Check if daemon is running
   - Check if pool is running
   - Check if configs exist
   - Check if dependencies are installed
   - Read logs to understand recent events

3. IDENTIFY GAPS: What&#039;s missing or broken?
   - No daemon? ‚Üí Need daemon setup
   - Daemon running but no pool? ‚Üí Need pool setup
   - Pool running but can&#039;t connect to daemon? ‚Üí Need recovery
   - Everything running but validation failed? ‚Üí Need validation

4. DECIDE FIRST DELEGATION: Who handles the first gap?
   - Missing dependencies? ‚Üí delegate_dependency_check
   - Need configs? ‚Üí delegate_config_generation
   - Need daemon? ‚Üí delegate_daemon_setup
   - Need pool? ‚Üí delegate_pool_setup
   - Need recovery? ‚Üí delegate_recovery
   - Need validation? ‚Üí delegate_validation

5. RETURN DECISION with clear reasoning:
   DECISION: delegate_daemon_setup
   REASONING: Daemon not running, all other components depend on it, start here.
```

### Subsequent Invocations (After Agent Returns)

When a specialist agent completes and returns control to you:

```
1. REVIEW OUTCOME: What did the agent accomplish?
   - Parse the agent&#039;s output
   - Identify success/failure/partial
   - Extract key details (error messages, component states, metrics)

2. UPDATE MENTAL STATE MODEL:
   - Mark completed tasks (dependencies ‚úì, daemon ‚úì, etc.)
   - Note any new information (Stratum port conflict detected, RPC working, etc.)
   - Track failure patterns (daemon crashed 3 times, always same error)

3. DECIDE NEXT ACTION:
   - Success? ‚Üí Move to next component in dependency order
   - Failure? ‚Üí Delegate to recovery OR escalate if unrecoverable
   - Partial? ‚Üí Complete remaining parts OR adapt plan
   - Everything done? ‚Üí Final validation OR declare complete

4. RETURN DECISION with updated reasoning:
   DECISION: delegate_pool_setup
   REASONING: Daemon now running and RPC verified, pool depends on daemon, proceed to pool setup.
```

## Delegation Decisions

### delegate_dependency_check

**When to use**:
- First time setup (no infrastructure exists)
- Agent reported missing dependency error
- User explicitly requested dependency verification

**Delegates to**: `dependency_installer` agent

**What the agent will do**:
- Check for bitcoind, CoiniumServ, miner software
- Install missing dependencies
- Return: `dependencies_ready` or `dependency_failure`

**What you do when agent returns**:
- `dependencies_ready` ‚Üí Move to `delegate_config_generation`
- `dependency_failure` ‚Üí Analyze what failed, decide: retry, escalate, or alternate approach

### delegate_config_generation

**When to use**:
- Dependencies installed but configs missing
- Configs exist but need regeneration (corrupted, wrong settings)
- User requested config update

**Delegates to**: `config_generator` agent

**What the agent will do**:
- Generate bitcoin.conf with correct RPC settings
- Generate pool config.json with daemon connection
- Create miner configuration
- Return: `configs_ready` or `config_failure`

**What you do when agent returns**:
- `configs_ready` ‚Üí Move to `delegate_daemon_setup`
- `config_failure` ‚Üí Analyze what failed, decide recovery strategy

### delegate_daemon_setup

**When to use**:
- Configs ready but daemon not running
- Daemon crashed and needs restart (after recovery agent cleared stale state)
- User requested daemon setup

**Delegates to**: `bitcoin_daemon_manager` agent

**What the agent will do**:
- Start bitcoind in regtest mode
- Wait for RPC to become available
- Generate 101 blocks to fund wallet
- Verify daemon health
- Return: `daemon_ready` or `daemon_failure`

**What you do when agent returns**:
- `daemon_ready` ‚Üí Move to `delegate_pool_setup`
- `daemon_failure` ‚Üí Delegate to recovery OR analyze failure pattern

### delegate_pool_setup

**When to use**:
- Daemon running but pool not running
- Pool crashed and needs restart (after recovery)
- User requested pool setup

**Delegates to**: `pool_server_manager` agent

**What the agent will do**:
- Start CoiniumServ.exe from correct directory
- Wait for Stratum port to listen
- Verify RPC connection to daemon
- Check getblocktemplate is working
- Return: `pool_ready` or `pool_failure`

**What you do when agent returns**:
- `pool_ready` ‚Üí Move to `delegate_miner_setup`
- `pool_failure` ‚Üí Check error details:
  - Stratum port conflict? ‚Üí Delegate to recovery
  - RPC connection failed? ‚Üí Check if daemon still alive, delegate to recovery
  - Unknown error? ‚Üí Analyze logs, decide recovery strategy

### delegate_miner_setup

**When to use**:
- Pool running and connected to daemon
- Miner needs configuration
- User requested miner setup

**Delegates to**: `miner_manager` agent

**What the agent will do**:
- Configure cpuminer with pool connection
- Set up mining wallet address
- Prepare miner to start (doesn&#039;t necessarily start it, just configures)
- Return: `miner_ready` or `miner_failure`

**What you do when agent returns**:
- `miner_ready` ‚Üí Move to `delegate_validation`
- `miner_failure` ‚Üí Delegate to recovery OR escalate if config issues

### delegate_validation

**When to use**:
- All components set up and running
- Need to verify end-to-end functionality
- User requested validation
- After recovery to verify infrastructure restored

**Delegates to**: `cycle_integration_tester` agent

**What the agent will do**:
- Verify daemon running and RPC accessible
- Verify pool running and connected to daemon
- Verify Stratum port accessible
- Check getblocktemplate flow
- Test full mining cycle (if miner running)
- Return: `validation_passed` or `validation_failed`

**What you do when agent returns**:
- `validation_passed` ‚Üí Return `DECISION: infrastructure_complete`
- `validation_failed` ‚Üí Analyze what failed:
  - Specific component down? ‚Üí Delegate to that component&#039;s setup
  - Connection issue? ‚Üí Delegate to recovery
  - Configuration issue? ‚Üí Delegate to config generation

### delegate_recovery

**When to use**:
- Any component failed to start or stopped unexpectedly
- Connection issues between components (daemon-pool, pool-miner)
- Stratum port conflicts
- RPC failures
- Stale locks detected
- Validation detected issues

**Delegates to**: `error_recovery_agent` agent

**What the agent will do**:
- Diagnose the specific failure type
- Execute appropriate recovery strategy:
  - Restart crashed components
  - Clear stale locks
  - Fix port conflicts
  - Reconnect components
  - Full environment reset (last resort)
- Return: `recovery_successful`, `recovery_failed`, or `environment_reset`

**What you do when agent returns**:
- `recovery_successful` ‚Üí Retry the component that failed (delegate back to its setup)
- `environment_reset` ‚Üí Start fresh: delegate to dependency check OR config generation
- `recovery_failed` ‚Üí Analyze failure count:
  - First failure? ‚Üí Try alternate recovery approach
  - Repeated failures? ‚Üí Return `DECISION: escalate` with diagnostic details

## Adaptive Decision-Making Patterns

### Pattern 1: Component Failure ‚Üí Recovery ‚Üí Retry

```
Attempt: delegate_daemon_setup
  ‚Üì
Outcome: daemon_failure (RPC timeout)
  ‚Üì
Decision: delegate_recovery
  ‚Üì
Outcome: recovery_successful (cleared stale lock, daemon restarted)
  ‚Üì
Decision: delegate_daemon_setup (retry)
  ‚Üì
Outcome: daemon_ready
  ‚Üì
Decision: delegate_pool_setup (proceed)
```

### Pattern 2: Cascading Failures ‚Üí Environment Reset ‚Üí Fresh Start

```
Attempt: delegate_pool_setup
  ‚Üì
Outcome: pool_failure (daemon connection refused)
  ‚Üì
Decision: delegate_daemon_setup (check daemon)
  ‚Üì
Outcome: daemon_failure (process crashed)
  ‚Üì
Decision: delegate_recovery
  ‚Üì
Outcome: recovery_failed (multiple restarts failed)
  ‚Üì
Decision: delegate_recovery (with reset strategy)
  ‚Üì
Outcome: environment_reset (full cleanup done)
  ‚Üì
Decision: delegate_daemon_setup (fresh start)
```

### Pattern 3: Stratum Port Conflict ‚Üí Recovery ‚Üí Alternate Port

```
Attempt: delegate_pool_setup
  ‚Üì
Outcome: pool_failure (Stratum port 3333 in use)
  ‚Üì
Decision: delegate_recovery
  ‚Üì
Outcome: recovery_successful (killed process on 3333 OR changed port to 13333)
  ‚Üì
Decision: delegate_pool_setup (retry with new port)
  ‚Üì
Outcome: pool_ready
  ‚Üì
Decision: delegate_miner_setup (proceed)
```

### Pattern 4: Partial Infrastructure ‚Üí Fill Gaps

```
Initial State Check:
  - Daemon: running ‚úì
  - Pool: not running ‚úó
  - Miner: not configured ‚úó
  ‚Üì
Decision: Skip to delegate_pool_setup (daemon already ready)
  ‚Üì
Outcome: pool_ready
  ‚Üì
Decision: delegate_miner_setup
  ‚Üì
Outcome: miner_ready
  ‚Üì
Decision: delegate_validation
  ‚Üì
Outcome: validation_passed
  ‚Üì
Decision: infrastructure_complete
```

### Pattern 5: Validation Failure ‚Üí Targeted Fix

```
Attempt: delegate_validation
  ‚Üì
Outcome: validation_failed (pool not receiving getblocktemplate from daemon)
  ‚Üì
Analysis: Daemon running, pool running, but RPC connection broken
  ‚Üì
Decision: delegate_recovery (RPC connection issue)
  ‚Üì
Outcome: recovery_successful (restarted pool with correct RPC config)
  ‚Üì
Decision: delegate_validation (re-validate)
  ‚Üì
Outcome: validation_passed
  ‚Üì
Decision: infrastructure_complete
```

## State Tracking

Maintain a mental model of infrastructure state across invocations:

```json
{
  &quot;dependencies&quot;: {
    &quot;status&quot;: &quot;installed&quot;,
    &quot;lastChecked&quot;: &quot;2025-01-22T10:15:00Z&quot;
  },
  &quot;configs&quot;: {
    &quot;status&quot;: &quot;generated&quot;,
    &quot;daemonConfig&quot;: &quot;~/.bitcoin/bitcoin.conf&quot;,
    &quot;poolConfig&quot;: &quot;/mnt/c/github/private-SuperCoinServ/build/bin/Debug/config.json&quot;
  },
  &quot;daemon&quot;: {
    &quot;status&quot;: &quot;running&quot;,
    &quot;rpcAccessible&quot;: true,
    &quot;blockHeight&quot;: 331,
    &quot;walletFunded&quot;: true
  },
  &quot;pool&quot;: {
    &quot;status&quot;: &quot;running&quot;,
    &quot;stratumPort&quot;: 3333,
    &quot;stratumAccessible&quot;: true,
    &quot;daemonConnected&quot;: true,
    &quot;getblocktemplateWorking&quot;: true
  },
  &quot;miner&quot;: {
    &quot;status&quot;: &quot;configured&quot;,
    &quot;walletAddress&quot;: &quot;bcrt1q...&quot;
  },
  &quot;failureHistory&quot;: [
    {&quot;component&quot;: &quot;pool&quot;, &quot;error&quot;: &quot;port_conflict&quot;, &quot;recovered&quot;: true, &quot;timestamp&quot;: &quot;2025-01-22T10:20:00Z&quot;}
  ]
}
```

Update this model after each agent execution based on their outputs.

## Failure Pattern Recognition

Learn from repeated failures:

```
Pattern Detected: Daemon crashes on startup 3 times with &quot;corrupted block database&quot;
  ‚Üì
Adaptive Strategy: Next recovery should delete regtest data directory before restart
  ‚Üì
Decision: delegate_recovery (with full reset strategy)
```

```
Pattern Detected: Pool fails to bind Stratum port on every attempt
  ‚Üì
Adaptive Strategy: Check for persistent process holding port, or switch to alternate port
  ‚Üì
Decision: delegate_recovery (with port conflict resolution strategy)
```

## Escalation Decision-Making

Know when to escalate instead of retrying:

**Escalate when**:
- Same failure occurred 5+ times despite recovery attempts
- Critical error detected (corrupted data, missing binaries, permission denied)
- Recovery agent reports `recovery_failed` multiple times
- User explicitly requested manual intervention in prompt
- Unrecognizable error pattern (no clear recovery strategy)

**Escalation format**:
```
DECISION: escalate

REASONING:
Cannot proceed with infrastructure setup due to persistent failures:

1. Daemon startup failed 5 times with error: &quot;corrupted block database&quot;
2. Recovery agent attempted full environment reset 2 times
3. All recovery strategies exhausted
4. Manual intervention required to investigate blockchain corruption

DIAGNOSTIC DETAILS:
- Bitcoin Core version: 0.21.0
- Regtest data directory: ~/.bitcoin/regtest
- Error in debug.log: &quot;Corrupted block database detected&quot;
- Attempted recoveries: restart (3x), stale lock cleanup (1x), full reset (2x)

SUGGESTED MANUAL ACTIONS:
1. Manually inspect ~/.bitcoin/regtest/blocks directory
2. Check for disk corruption with filesystem check
3. Consider reinstalling Bitcoin Core
4. Verify sufficient disk space and permissions
```

## Output Format

Every invocation MUST end with a clear DECISION and REASONING:

**Format**:
```
DECISION: &lt;decision_keyword&gt;

REASONING:
&lt;Clear explanation of why you made this decision, including:&gt;
- Current infrastructure state
- What you analyzed
- What gaps or issues you identified
- Why this delegation/action is the right next step
- Dependencies satisfied for this action
```

**Decision Keywords** (use EXACTLY these):
- `delegate_dependency_check`
- `delegate_config_generation`
- `delegate_daemon_setup`
- `delegate_pool_setup`
- `delegate_miner_setup`
- `delegate_validation`
- `delegate_recovery`
- `infrastructure_complete`
- `escalate`

## Example Execution Flows

### Example 1: Fresh Setup

**Invocation 1** (User: &quot;Set up mining infrastructure from scratch&quot;):
```
DECISION: delegate_dependency_check

REASONING:
Starting fresh infrastructure setup. First step is to verify all required software is installed:
- bitcoind (Bitcoin Core)
- Mono runtime (for CoiniumServ)
- cpuminer (mining software)

No existing components detected. Dependencies are the foundation - must be installed before configs can be generated.
```

**Invocation 2** (dependency_installer returned: `dependencies_ready`):
```
DECISION: delegate_config_generation

REASONING:
Dependency installer confirmed all software installed:
- bitcoind found at /usr/local/bin/bitcoind
- Mono runtime version 6.12
- cpuminer available

Next step: generate configuration files for daemon, pool, and miner. Configs must be created before components can start.
```

**Invocation 3** (config_generator returned: `configs_ready`):
```
DECISION: delegate_daemon_setup

REASONING:
Configuration files generated successfully:
- bitcoin.conf created with RPC settings (user: pooltest, port: 18443)
- Pool config.json created with daemon connection
- Miner config prepared

Daemon is the foundation component - all other components depend on it. Starting daemon setup.
```

**Invocation 4** (bitcoin_daemon_manager returned: `daemon_ready`):
```
DECISION: delegate_pool_setup

REASONING:
Daemon successfully started and operational:
- Process running (PID 12345)
- RPC accessible on port 18443
- Wallet funded with 25 BTC from 101 generated blocks
- Block height: 101

Daemon dependency satisfied. Pool can now connect to daemon for getblocktemplate. Starting pool setup.
```

**Invocation 5** (pool_server_manager returned: `pool_ready`):
```
DECISION: delegate_miner_setup

REASONING:
Pool successfully started and connected:
- CoiniumServ process running
- Stratum port 3333 listening
- RPC connection to daemon verified
- getblocktemplate working (receiving block templates)

Pool dependency satisfied. Miner can now connect to pool for mining jobs. Configuring miner.
```

**Invocation 6** (miner_manager returned: `miner_ready`):
```
DECISION: delegate_validation

REASONING:
Miner configured successfully:
- cpuminer configured with pool connection (stratum+tcp://localhost:3333)
- Wallet address set: bcrt1q7x8k9...
- Ready to start mining

All components set up. Final step: validate end-to-end infrastructure to ensure all components communicate correctly.
```

**Invocation 7** (cycle_integration_tester returned: `validation_passed`):
```
DECISION: infrastructure_complete

REASONING:
Full infrastructure validation passed:
- Daemon: running, RPC accessible, block height 101, wallet funded
- Pool: running, Stratum accessible, connected to daemon, getblocktemplate working
- Miner: configured, can connect to pool
- End-to-end flow verified: daemon ‚Üí pool ‚Üí miner ready

All components operational and validated. Infrastructure setup complete.
```

### Example 2: Recovery from Stratum Port Conflict

**Invocation 1** (User: &quot;Set up mining infrastructure&quot;):
```
DECISION: delegate_daemon_setup

REASONING:
Checked existing state:
- Dependencies: installed ‚úì
- Configs: exist ‚úì
- Daemon: not running ‚úó
- Pool: not running ‚úó

Skipping dependency check and config generation since they&#039;re already done. Starting with daemon setup.
```

**Invocation 2** (bitcoin_daemon_manager returned: `daemon_ready`):
```
DECISION: delegate_pool_setup

REASONING:
Daemon started successfully. RPC accessible. Proceeding to pool setup.
```

**Invocation 3** (pool_server_manager returned: `pool_failure` with error: &quot;Stratum port 3333 already in use&quot;):
```
DECISION: delegate_recovery

REASONING:
Pool failed to start due to Stratum port conflict:
- Error: &quot;Stratum port 3333 already in use&quot;
- Daemon is running and healthy
- Pool process did not start

Delegating to error recovery agent to resolve port conflict (kill conflicting process or change port).
```

**Invocation 4** (error_recovery_agent returned: `recovery_successful` with note: &quot;Changed Stratum port to 13333, pool restarted&quot;):
```
DECISION: delegate_validation

REASONING:
Recovery successful:
- Port conflict resolved by changing Stratum port from 3333 to 13333
- Pool restarted and now listening on port 13333
- Daemon connection verified

Skipping miner setup for now (can configure miner with new port later if needed). Proceeding to validation to confirm infrastructure is operational.
```

**Invocation 5** (cycle_integration_tester returned: `validation_passed`):
```
DECISION: infrastructure_complete

REASONING:
Validation passed with updated configuration:
- Daemon: running and healthy
- Pool: running on Stratum port 13333, connected to daemon
- Infrastructure operational despite port conflict (resolved automatically)

Setup complete with adaptive port configuration.
```

## Key Principles

1. **Always check current state first** - Don&#039;t assume infrastructure state, verify it
2. **Delegate to specialists** - Don&#039;t do the work yourself, route to expert agents
3. **Adapt to outcomes** - Success/failure should change your next decision
4. **Learn from failures** - Pattern detected? Adjust strategy
5. **Respect dependencies** - Daemon before pool, pool before miner
6. **Escalate when stuck** - Don&#039;t retry infinitely, know when to ask for help
7. **Provide clear reasoning** - Every decision should be explainable
8. **Track state across invocations** - Remember what&#039;s been done
9. **Optimize when possible** - Skip unnecessary steps if already complete
10. **Always end with a DECISION** - Never leave the pipeline hanging

## Tools Available

You have access to:
- **Bash**: Check process status, ports, files, run quick diagnostics
- **Read**: Read logs, configs, state files
- **Grep**: Search logs for patterns
- **Glob**: Find files

Use these to **assess current state** before making delegation decisions.

Example state checks:
```bash
# Check if daemon running
pgrep -f &quot;bitcoind.*regtest&quot;

# Check if pool running
tasklist.exe | grep CoiniumServ

# Check ports
netstat -tuln | grep -E &#039;18443|3333&#039;

# Check recent logs
tail -50 ~/.bitcoin/regtest/debug.log
tail -50 /mnt/c/github/private-SuperCoinServ/build/bin/Debug/logs/debug.log
```

Use this information to make informed delegation decisions!

---

You are the intelligent orchestrator. Think strategically, delegate wisely, adapt continuously, and always explain your reasoning clearly.

=== ROUTING DECISION REQUIRED ===
After your response, you MUST choose exactly ONE decision from:
- delegate_dependency_check: Need to verify or install dependencies
- delegate_config_generation: Need to generate configuration files
- delegate_daemon_setup: Need to set up Bitcoin daemon
- delegate_pool_setup: Need to set up pool server
- delegate_miner_setup: Need to configure miner
- delegate_validation: Need to validate infrastructure
- delegate_recovery: Detected failure, need error recovery
- infrastructure_complete: All infrastructure operational and validated
- escalate: Cannot proceed, manual intervention required

**CRITICAL**: Your VERY LAST LINE must be exactly:
DECISION: [ONE_OF_THE_ABOVE_CHOICES]
Example: DECISION: delegate_dependency_check
Do NOT add explanations after the decision keyword.
</pre>
        </div>
      </div>
      

      
      <div class="output-section">
        <div class="section-label">üì§ AGENT OUTPUT <span class="char-count">(3,358 characters)</span></div>
        <button class="collapsible" data-target="output_orchestrate_1">Click to expand output from infrastructure_orchestrator</button>
        <div class="collapsible-content" id="output_orchestrate_1">
          <pre class="code-content">The errors are continuous and recent (21:45:47, which is recent). The pool cannot connect to the daemon RPC despite:
1. Daemon running with correct RPC settings
2. RPC accessible via curl
3. Credentials matching

This is a clear RPC connectivity failure that needs recovery. Let me create a comprehensive state assessment:

## INFRASTRUCTURE STATE ANALYSIS

### Current State Assessment:

**Dependencies:**
- bitcoind: Process running (PIDs 38018, 51969) ‚úì
- CoiniumServ: Binary exists and process running (PID 45147) ‚úì
- Mining software: NOT installed ‚úó

**Configurations:**
- Daemon config: Exists at ~/.bitcoin/bitcoin.conf with correct RPC settings ‚úì
- Pool config: Exists with matching RPC credentials (user: coiniumtest, pass: testpass123) ‚úì
- Pool definition: default.json properly configured ‚úì

**Running Components:**
- Daemon: Running, RPC port 18443 listening, blockchain at height 331 ‚úì
- Daemon RPC: Verified working via curl test ‚úì
- Pool: Running, Stratum port 3333 listening ‚ö†Ô∏è
- Pool-to-Daemon connection: **FAILING** - &quot;Connection refused&quot; errors ‚úó

**Identified Issues:**
1. **Critical**: Pool cannot connect to daemon RPC despite both running and daemon being accessible
   - Error: &quot;Connection refused&quot; when trying to call getblocktemplate
   - Daemon RPC works when tested directly with curl
   - This suggests either:
     a) Mono/.NET HTTP client networking issue
     b) Firewall/routing issue specific to the pool process
     c) RPC bind configuration issue (daemon bound to 127.0.0.1, pool trying to connect)

2. **Missing**: No mining software (cpuminer/minerd) installed

### Gap Analysis:

**Immediate blocker**: Pool-Daemon RPC connectivity failure preventing getblocktemplate, which means no mining jobs can be created.

**Next gap**: Miner software not installed (but this is blocked by pool connectivity issue anyway)

### Failure Pattern:
Recent logs show continuous &quot;Connection refused&quot; errors from JobManager when trying to create new jobs via getblocktemplate. This is a persistent failure requiring recovery intervention.

---

## ROUTING DECISION

The infrastructure has partial setup:
- Daemon running and healthy ‚úì
- Pool running but cannot communicate with daemon ‚úó
- Miner not installed ‚úó

This is a **recovery scenario** where an existing component (pool) is running but failing to function properly due to RPC connectivity issues. The recovery agent should:
1. Diagnose the RPC connection failure
2. Attempt fixes (restart pool, check networking, verify RPC bind settings)
3. If recovery successful, then we can proceed to miner setup
4. If recovery fails, may need to regenerate configs or escalate

REASONING:
Current state shows both daemon and pool processes running with ports listening, but pool JobManager cannot establish RPC connection to daemon despite correct credentials and daemon being accessible via curl. This is a classic infrastructure failure requiring the error_recovery_agent to diagnose and fix the RPC connectivity issue between pool and daemon. The daemon is healthy and verified working, so the issue is specifically with pool-to-daemon communication. Recovery must fix this before we can proceed to miner setup and validation.

Dependencies for recovery action: Both components running (satisfied), configs exist (satisfied), just need to fix connectivity.

DECISION: delegate_recovery</pre>
        </div>
      </div>
      

      

      
      <div class="routing-info">
        <div class="routing-decision">üîÄ Routing Decision: DELEGATE_RECOVERY</div>
        <div style="font-size: 0.9em; color: #555; margin-top: 5px;">Decision &quot;DELEGATE_RECOVERY&quot; matched connection condition</div>
        <div style="margin-top: 10px; font-weight: bold;">‚Üí Next Stage: <strong>handle_recovery</strong></div>
      </div>
      
    </div>

    <div class="stage completed">
      <div class="stage-header">
        <div>
          <div class="stage-title">Handle Error Recovery</div>
          <div style="color: #6c757d; font-size: 0.9em; margin-top: 5px;">Diagnose failures, execute recovery strategies, report outcomes to orchestrator</div>
        </div>
        <span class="stage-badge badge-completed">completed</span>
      </div>

      <div class="stage-meta">
        <div class="meta-item">
          <span class="meta-label">Agent:</span>
          <span class="meta-value">error_recovery_agent</span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Type:</span>
          <span class="meta-value"></span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Duration:</span>
          <span class="meta-value">602.8s</span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Execution #:</span>
          <span class="meta-value">2</span>
        </div>
        
        <div class="meta-item">
          <span class="meta-label">Prompt Size:</span>
          <span class="meta-value">27,753 chars</span>
        </div>
        
        
        <div class="meta-item">
          <span class="meta-label">Output Size:</span>
          <span class="meta-value">3,467 chars</span>
        </div>
        
      </div>

      
      <div class="prompt-section">
        <div class="section-label">üì• AGENT PROMPT <span class="char-count">(27,753 characters)</span></div>
        <button class="collapsible" data-target="prompt_handle_recovery_2">Click to expand prompt from error_recovery_agent</button>
        <div class="collapsible-content" id="prompt_handle_recovery_2">
          <pre class="code-content">You are an Error Recovery Agent specialized in detecting and automatically recovering from failures in cryptocurrency mining pool infrastructure.

## Core Responsibilities

Your primary role is to detect failures across the mining pool stack (Bitcoin daemon, pool server, miners) and execute appropriate recovery strategies to restore normal operation with minimal manual intervention.

## Failure Detection Capabilities

### 1. Daemon Crash Detection

**Detection Methods**:
- Monitor bitcoind process: `pgrep -f bitcoind.*regtest` or `ps aux | grep bitcoind`
- Test RPC responsiveness: `bitcoin-cli -regtest ping` or `getblockchaininfo`
- Check for unexpected process termination
- Monitor debug.log for crash signatures
- Verify daemon uptime using `bitcoin-cli -regtest uptime`

**Crash Indicators**:
- Process not found in process list
- RPC connection refused or timeout
- Lock file exists but no process (stale lock)
- Debug.log shows crash or abort message
- Sudden stop in log activity with no shutdown message

**Detection Frequency**: Poll every 10-15 seconds during critical operations

### 2. RPC Failure Detection

**Detection Methods**:
- Test RPC connectivity with lightweight command (ping, getblockcount)
- Monitor RPC call success/failure rates
- Check for authentication errors
- Verify RPC port accessibility: `nc -zv localhost 18443` or `curl http://localhost:18443`
- Parse error responses from RPC calls

**RPC Failure Types**:

1. **Connection Refused**:
   - Error: &quot;Could not connect to the server&quot;
   - Cause: Daemon not running or wrong port
   - Detection: TCP connection fails to RPC port

2. **Authentication Failed**:
   - Error: &quot;401 Unauthorized&quot; or &quot;Incorrect rpcuser or rpcpassword&quot;
   - Cause: Wrong credentials
   - Detection: HTTP 401 response or auth error message

3. **Timeout**:
   - Error: &quot;Timeout waiting for response&quot;
   - Cause: Daemon overloaded or network issue
   - Detection: RPC call exceeds timeout threshold (default 30s)

4. **Network Unreachable**:
   - Error: &quot;Network is unreachable&quot;
   - Cause: Network configuration issue
   - Detection: Socket connection error

5. **Daemon Still Loading**:
   - Error: &quot;Loading block index&quot; or &quot;Verifying blocks&quot;
   - Cause: Daemon starting up
   - Detection: Specific warmup error codes

**RPC Health Check**:
```bash
# Quick connectivity test
bitcoin-cli -regtest -rpcuser=pooltest -rpcpassword=pooltest123 getblockcount

# Port accessibility
netstat -tuln | grep 18443

# Curl test
curl -s --user pooltest:pooltest123 --data-binary &#039;{&quot;jsonrpc&quot;:&quot;1.0&quot;,&quot;id&quot;:&quot;test&quot;,&quot;method&quot;:&quot;getblockcount&quot;,&quot;params&quot;:[]}&#039; -H &#039;content-type: text/plain;&#039; http://127.0.0.1:18443/
```

### 3. Pool Disconnection Detection

**Detection Methods**:
- Check CoiniumServ.exe process: `tasklist.exe | grep -i CoiniumServ`
- Verify Stratum port listening: `netstat -ano | grep :3333`
- Monitor pool logs for disconnect events
- Test Stratum connectivity: `nc -zv localhost 3333` or `telnet localhost 3333`
- Check for RPC connection errors in pool logs (indicates daemon disconnection)

**Pool Disconnection Indicators**:
- CoiniumServ process terminated
- Stratum port not listening
- Pool logs show &quot;Cannot connect to daemon&quot;
- Pool logs show &quot;RPC error&quot; repeatedly
- Miners cannot connect (connection refused)
- No getblocktemplate activity in pool logs

**Log Patterns to Monitor**:
```
ERROR.*Cannot connect
RPC.*timeout
Connection refused
Daemon.*unreachable
Stratum.*failed
```

### 4. Miner Error Detection

**Detection Methods**:
- Monitor miner process status
- Parse miner output for error messages
- Check for repeated share rejections
- Detect connection failures to pool
- Monitor for authentication errors
- Track unexpected process exits

**Miner Error Patterns**:
- &quot;Connection refused&quot; - Pool not accessible
- &quot;Authentication failed&quot; - Wrong credentials
- &quot;Share rejected&quot; (high rate) - Difficulty or timing issues
- Process crash or exit code != 0
- No share submissions for extended period
- &quot;Stratum error&quot; messages

### 5. Stale Lock Detection

**Lock File Locations**:
- Bitcoin daemon: `~/.bitcoin/regtest/.lock` or `&lt;datadir&gt;/regtest/.lock`
- Pool database locks: `&lt;pooldir&gt;/data/*.lock`
- Custom lock files created by scripts

**Stale Lock Detection**:
```bash
# Find all .lock files
find ~/.bitcoin/regtest -name &quot;*.lock&quot;

# Check if lock owner process exists
if [ -f ~/.bitcoin/regtest/.lock ]; then
  # Lock exists, check if bitcoind running
  if ! pgrep -f &quot;bitcoind.*regtest&quot; &gt; /dev/null; then
    echo &quot;Stale lock detected&quot;
  fi
fi
```

**Lock Validation**:
- Check if lock file exists
- Verify owning process is still running
- Check lock age (old locks may be stale)
- Ensure lock is for current operation

### 6. Environment Health Monitoring

**System Checks**:
- Disk space: `df -h` (ensure sufficient space for blocks/logs)
- Memory usage: `free -h` (detect memory leaks)
- Port conflicts: `netstat -tuln | grep -E &#039;18443|18444|3333&#039;`
- File descriptor limits: `ulimit -n`
- Zombie processes: `ps aux | grep -E &#039;defunct|&lt;zombie&gt;&#039;`

**Resource Thresholds**:
- Disk space &lt; 1GB: Warning
- Memory usage &gt; 90%: Warning  
- Open file descriptors &gt; 80% of limit: Warning
- Zombie processes detected: Investigate

## Recovery Strategies

### Strategy 1: Daemon Crash Recovery

**Recovery Procedure**:

1. **Detect Crash**:
   - Process not running
   - RPC connection failed
   - Lock file may be stale

2. **Diagnose**:
   - Check debug.log for crash reason:
     ```bash
     tail -100 ~/.bitcoin/regtest/debug.log | grep -E &quot;ERROR|EXCEPTION|Shutdown|Aborted&quot;
     ```
   - Note: crash dump, assertion failure, corruption

3. **Clean Stale Locks** (if needed):
   ```bash
   if [ -f ~/.bitcoin/regtest/.lock ]; then
     if ! pgrep -f &quot;bitcoind.*regtest&quot; &gt; /dev/null; then
       rm -f ~/.bitcoin/regtest/.lock
       echo &quot;Removed stale lock&quot;
     fi
   fi
   ```

4. **Restart Daemon**:
   ```bash
   bitcoind -regtest -daemon -datadir=~/.bitcoin
   ```

5. **Verify Recovery**:
   - Wait 10-15 seconds for initialization
   - Test RPC: `bitcoin-cli -regtest getblockchaininfo`
   - Check process running: `pgrep -f bitcoind.*regtest`
   - Verify uptime: `bitcoin-cli -regtest uptime` (should be low)

6. **Document Recovery**:
   - Log timestamp of crash
   - Log crash reason from debug.log
   - Log recovery success/failure
   - Increment recovery counter

**Escalation Conditions**:
- Crash occurs &gt; 3 times in 10 minutes
- Crash reason is &quot;corrupted block database&quot;
- Recovery fails after 3 attempts
- Debug.log shows critical errors

### Strategy 2: RPC Failure Recovery

**Recovery Procedure**:

1. **Classify RPC Failure**:
   - Connection refused ‚Üí Daemon likely not running
   - Authentication error ‚Üí Credentials mismatch
   - Timeout ‚Üí Daemon overloaded or network issue
   - Still loading ‚Üí Wait for daemon warmup

2. **Recovery by Type**:

   **Connection Refused**:
   - Check if daemon running: `pgrep -f bitcoind.*regtest`
   - If not running: Execute daemon crash recovery
   - If running: Check port binding:
     ```bash
     netstat -tuln | grep 18443
     ```
   - Restart daemon if port not bound

   **Authentication Failed**:
   - Verify credentials in bitcoin.conf:
     ```bash
     grep -E &quot;rpcuser|rpcpassword&quot; ~/.bitcoin/bitcoin.conf
     ```
   - Check credentials used in RPC call match config
   - If mismatch: Update config or fix call
   - Restart daemon to reload config if changed

   **Timeout**:
   - Check daemon responsiveness: `bitcoin-cli -regtest ping`
   - Check daemon CPU/memory usage: `top -p $(pgrep bitcoind)`
   - Increase RPC timeout if daemon legitimately busy
   - Restart daemon if frozen/unresponsive

   **Still Loading**:
   - Wait for daemon initialization (up to 30 seconds)
   - Poll with `getblockchaininfo` every 2 seconds
   - If loading &gt; 60 seconds, investigate debug.log
   - May be validating blocks (normal in some cases)

3. **Verify RPC Recovery**:
   ```bash
   # Test basic RPC
   bitcoin-cli -regtest getblockcount
   
   # Test authenticated RPC
   bitcoin-cli -regtest -rpcuser=pooltest -rpcpassword=pooltest123 getblockchaininfo
   
   # Test from pool&#039;s perspective (if pool config uses different creds)
   curl --user pooltest:pooltest123 --data-binary &#039;{&quot;method&quot;:&quot;getblockcount&quot;}&#039; http://127.0.0.1:18443/
   ```

4. **Notify Dependent Components**:
   - Inform pool_server_manager that daemon RPC is restored
   - Trigger pool reconnection if pool was disconnected
   - Resume monitoring by network_monitor

**Recovery Success Criteria**:
- RPC calls succeed consistently (3+ successful calls)
- Response times normal (&lt; 1 second for simple calls)
- No authentication errors
- Daemon reports healthy status

### Strategy 3: Pool Disconnection Recovery

**Recovery Procedure**:

1. **Detect Disconnection Type**:
   - Pool process crashed
   - Pool lost connection to daemon
   - Stratum port stopped responding

2. **Diagnose Root Cause**:
   - Check pool logs:
     ```bash
     tail -100 /mnt/c/github/private-SuperCoinServ/build/bin/Debug/logs/debug.log | grep -i error
     ```
   - Look for: RPC errors, exceptions, crashes
   - Check if daemon is accessible (RPC test)
   - Check if port 3333 is free (no conflicts)

3. **Recovery Steps**:

   **If Pool Process Crashed**:
   - Verify process not running: `tasklist.exe | grep CoiniumServ`
   - Check port released: `netstat -ano | grep :3333`
   - Review crash logs for errors
   - Restart pool server:
     ```bash
     cd /mnt/c/github/private-SuperCoinServ/build/bin/Debug
     cmd.exe /c &quot;CoiniumServ.exe&quot; &gt; pool-console.log 2&gt;&amp;1 &amp;
     ```
   - Wait 10 seconds for initialization
   - Verify Stratum listening: `netstat -ano | grep :3333`

   **If Pool Lost Daemon Connection**:
   - Verify daemon is running and RPC accessible
   - If daemon down: Execute daemon recovery first
   - If daemon up: Check pool config for correct RPC credentials
   - Restart pool to reestablish connection
   - Monitor pool logs for &quot;Connected to daemon&quot; message

   **If Stratum Port Issue**:
   - Check for port conflict: `netstat -ano | grep :3333`
   - Kill conflicting process if found
   - Or change pool config to use different port
   - Restart pool

4. **Verify Pool Recovery**:
   ```bash
   # Process running
   tasklist.exe | grep -i CoiniumServ
   
   # Port listening
   netstat -ano | grep :3333 | grep LISTENING
   
   # Test connection
   nc -zv localhost 3333 || telnet localhost 3333
   
   # Check logs for daemon connection
   tail -50 build/bin/Debug/logs/debug.log | grep -i &quot;connected\|daemon\|getblocktemplate&quot;
   ```

5. **Reconnect Miners**:
   - Miners should auto-reconnect to pool
   - Monitor for &quot;Miner connected&quot; events in logs
   - Verify share submissions resume

**Recovery Success Criteria**:
- Pool process running
- Stratum port listening on 3333
- Pool logs show successful daemon connection
- getblocktemplate calls visible in logs
- Miners can connect and submit shares

### Strategy 4: Miner Error Recovery

**Recovery Procedure**:

1. **Identify Miner Error Type**:
   - Connection error ‚Üí Pool accessibility issue
   - Authentication error ‚Üí Wrong credentials
   - Share rejection ‚Üí Difficulty/configuration issue
   - Process crash ‚Üí Miner software bug

2. **Recovery by Error Type**:

   **Connection Error**:
   - Verify pool Stratum port accessible: `nc -zv localhost 3333`
   - If pool down: Execute pool recovery
   - Check network connectivity between miner and pool
   - Restart miner once pool accessible

   **Authentication Error**:
   - Verify miner credentials configured correctly
   - Check pool allows anonymous mining (if relevant)
   - Update miner config with correct username.worker format
   - Restart miner with corrected config

   **High Share Rejection**:
   - Check difficulty settings in pool config
   - Verify miner not submitting stale shares (timing issue)
   - Check for clock sync between miner and pool
   - May indicate pool or daemon issue (escalate if pool-wide)

   **Miner Crash**:
   - Review miner output/logs for crash reason
   - Check for: segfault, OOM, assertion failure
   - Ensure miner binary is compatible with system
   - Restart miner process
   - If crashes persist: Switch to alternative miner software

3. **Miner Restart Procedure**:
   ```bash
   # Stop miner gracefully
   pkill -TERM cpuminer
   # or for specific miner
   kill -TERM &lt;miner_pid&gt;
   
   # Wait for clean exit (max 10 seconds)
   sleep 2
   
   # Force kill if still running
   pkill -KILL cpuminer
   
   # Clear any state files if needed
   rm -f /tmp/miner.state
   
   # Restart miner
   cpuminer -a sha256d -o stratum+tcp://localhost:3333 -u miner -p x &amp;
   ```

4. **Verify Miner Recovery**:
   - Process running: `pgrep cpuminer`
   - Miner output shows &quot;Stratum connected&quot;
   - Shares being submitted (monitor output)
   - Pool logs show &quot;Miner connected&quot;
   - Share acceptance rate normal (&gt;95%)

**Recovery Success Criteria**:
- Miner process running stable
- Connected to pool Stratum
- Submitting shares successfully
- Low rejection rate (&lt; 5%)
- No repeated errors in output

### Strategy 5: Stale Lock Cleanup

**Recovery Procedure**:

1. **Identify Stale Locks**:
   ```bash
   # Find all lock files
   find ~/.bitcoin/regtest -name &quot;*.lock&quot; -o -name &quot;.lock&quot;
   find /mnt/c/github/private-SuperCoinServ -name &quot;*.lock&quot;
   
   # Check daemon lock specifically
   if [ -f ~/.bitcoin/regtest/.lock ]; then
     echo &quot;Daemon lock exists&quot;
   fi
   ```

2. **Validate Lock Ownership**:
   ```bash
   # Check if bitcoind process running
   if pgrep -f &quot;bitcoind.*regtest&quot; &gt; /dev/null; then
     echo &quot;Daemon running - lock is VALID&quot;
   else
     echo &quot;Daemon not running - lock is STALE&quot;
   fi
   ```

3. **Safe Lock Removal**:
   ```bash
   # ONLY remove if validated as stale
   # Never remove lock while process running
   
   if [ -f ~/.bitcoin/regtest/.lock ]; then
     # Double check no daemon process
     if ! pgrep -f &quot;bitcoind.*regtest&quot; &gt; /dev/null; then
       # Safe to remove
       rm -f ~/.bitcoin/regtest/.lock
       echo &quot;Removed stale daemon lock&quot;
     else
       echo &quot;WARNING: Daemon running, NOT removing lock&quot;
     fi
   fi
   ```

4. **Lock Removal for Different Components**:

   **Bitcoin Daemon Lock**:
   - Location: `~/.bitcoin/regtest/.lock`
   - Validation: Check `pgrep bitcoind`
   - Remove only if daemon not running

   **Pool Database Locks**:
   - Location: Pool data directory
   - Validation: Check `tasklist.exe | grep CoiniumServ`
   - Remove only if pool not running

   **Custom Script Locks**:
   - Location: `/tmp/` or script-specific directories
   - Validation: Check if script process running (by PID or name)
   - Check lock age (very old locks likely stale)

5. **Post-Cleanup Verification**:
   - Ensure lock file removed: `ls -la ~/.bitcoin/regtest/.lock`
   - Verify component can now start
   - Start component and confirm no lock errors
   - Monitor for lock file recreation (should happen normally)

**Safety Rules**:
- NEVER remove lock while owning process is running
- Always validate lock is stale before removal
- Prefer stopping process gracefully over forcing lock removal
- Log all lock removals with timestamp and reason
- Backup lock file content before removal (may contain PID)

### Strategy 6: Test Environment Reset

**Full Environment Reset Procedure**:

1. **Stop All Components** (in order):
   ```bash
   # Stop miners first
   pkill -TERM cpuminer
   sleep 2
   pkill -KILL cpuminer
   
   # Stop pool server
   taskkill.exe /IM CoiniumServ.exe
   sleep 5
   taskkill.exe /F /IM CoiniumServ.exe 2&gt;/dev/null
   
   # Stop Bitcoin daemon last
   bitcoin-cli -regtest stop
   sleep 10
   # Force if needed
   pkill -KILL bitcoind
   ```

2. **Verify All Stopped**:
   ```bash
   # No miners running
   pgrep cpuminer || echo &quot;Miners stopped&quot;
   
   # No pool running
   tasklist.exe | grep CoiniumServ || echo &quot;Pool stopped&quot;
   
   # No daemon running
   pgrep bitcoind || echo &quot;Daemon stopped&quot;
   
   # Ports released
   netstat -tuln | grep -E &#039;18443|18444|3333&#039; || echo &quot;Ports free&quot;
   ```

3. **Clean Data Directories**:
   ```bash
   # Clean daemon regtest data (preserves config)
   rm -rf ~/.bitcoin/regtest/
   echo &quot;Bitcoin regtest data cleared&quot;
   
   # Clean pool data/logs (be careful not to delete config)
   rm -rf /mnt/c/github/private-SuperCoinServ/build/bin/Debug/logs/*
   rm -rf /mnt/c/github/private-SuperCoinServ/build/bin/Debug/data/*
   echo &quot;Pool data cleared&quot;
   
   # Clean lock files
   find ~/.bitcoin -name &quot;*.lock&quot; -delete
   echo &quot;Lock files removed&quot;
   
   # Clean temp files
   rm -f /tmp/mining-*.tmp
   rm -f /tmp/pool-*.pid
   echo &quot;Temp files cleaned&quot;
   ```

4. **Reset Configurations** (optional):
   ```bash
   # Regenerate bitcoin.conf with fresh settings
   # (Usually preserve existing config unless requested)
   
   # Reset pool config to defaults
   # (Usually preserve unless requested)
   
   # Clear miner state
   ```

5. **Restart Components** (in order):
   ```bash
   # Start daemon first
   bitcoind -regtest -daemon
   sleep 15
   
   # Verify daemon ready
   bitcoin-cli -regtest getblockchaininfo
   
   # Generate initial blocks if needed (fresh regtest)
   ADDR=$(bitcoin-cli -regtest getnewaddress)
   bitcoin-cli -regtest generatetoaddress 101 $ADDR
   
   # Start pool server
   cd /mnt/c/github/private-SuperCoinServ/build/bin/Debug
   cmd.exe /c &quot;CoiniumServ.exe&quot; &gt; pool-console.log 2&gt;&amp;1 &amp;
   sleep 10
   
   # Verify pool ready
   netstat -ano | grep :3333
   
   # Start miners
   cpuminer -a sha256d -o stratum+tcp://localhost:3333 -u miner -p x &amp;
   sleep 5
   
   # Verify miner connected
   tail -20 build/bin/Debug/logs/debug.log | grep -i &quot;miner connected&quot;
   ```

6. **Verify Environment Ready**:
   ```bash
   # All processes running
   pgrep bitcoind &amp;&amp; echo &quot;‚úì Daemon running&quot;
   tasklist.exe | grep CoiniumServ &amp;&amp; echo &quot;‚úì Pool running&quot;
   pgrep cpuminer &amp;&amp; echo &quot;‚úì Miner running&quot;
   
   # All ports listening
   netstat -tuln | grep 18443 &amp;&amp; echo &quot;‚úì RPC port open&quot;
   netstat -ano | grep 3333 &amp;&amp; echo &quot;‚úì Stratum port open&quot;
   
   # RPC working
   bitcoin-cli -regtest getblockcount &amp;&amp; echo &quot;‚úì RPC functional&quot;
   
   # Pool connected to daemon
   tail -10 build/bin/Debug/logs/debug.log | grep -i &quot;getblocktemplate&quot; &amp;&amp; echo &quot;‚úì Pool connected&quot;
   
   # Miner submitting shares
   # (Wait 30-60 seconds for first share)
   ```

**Reset Types**:

- **Soft Reset**: Stop and restart components without clearing data
- **Data Reset**: Clear regtest blockchain and pool data, preserve configs
- **Full Reset**: Clear all data, regenerate configs, fresh start
- **Config Reset**: Regenerate all configuration files

**When to Reset**:
- After repeated recovery failures
- Corrupted blockchain state detected
- Configuration drift or inconsistency
- Between test scenarios
- Before major changes to setup
- User explicitly requests clean slate

## Error Escalation

**Escalation Triggers**:

1. **Recovery Failure** - Recovery attempted 3+ times without success
2. **Repeated Crashes** - Same component crashes &gt;3 times in 10 minutes
3. **Cascading Failures** - Multiple components failing simultaneously
4. **Critical Errors** - Corruption detected, security issues, data loss
5. **Resource Exhaustion** - Out of disk, memory, or file descriptors

**Escalation Actions**:

1. **Notify User**:
   - Generate alert with error details
   - Include failure timeline and recovery attempts
   - Provide diagnostic information
   - Suggest manual intervention steps

2. **Trigger Emergency Shutdown** (if configured):
   - Stop all components safely
   - Preserve logs and state for analysis
   - Prevent further damage
   - Wait for manual resolution

3. **Generate Diagnostic Report**:
   - Collect logs from all components
   - Gather system information
   - Document error timeline
   - Include recovery attempts and outcomes
   - Save to diagnostics directory

4. **Log to Escalation Record**:
   - Timestamp and error type
   - Recovery strategies attempted
   - Reason for escalation
   - Suggested next steps

## Recovery Coordination

**Multi-Component Recovery**:

When multiple components fail, recover in dependency order:

1. **Bitcoin Daemon** (foundation)
   - All other components depend on daemon
   - Recover daemon first
   - Verify RPC accessible before proceeding

2. **Pool Server** (middle tier)
   - Depends on daemon
   - Required for miners
   - Recover after daemon stable

3. **Miners** (top tier)
   - Depend on pool
   - Recover last
   - Can run multiple in parallel

**Component Dependencies**:
```
Miners ‚Üí Pool Server ‚Üí Bitcoin Daemon
```

**Recovery Sequencing**:
- Bottom-up: Start with daemon, then pool, then miners
- Verify each layer before starting next
- Allow initialization time between layers
- Revert to environment reset if sequenced recovery fails

## Monitoring and Logging

**Recovery Metrics**:
- Total recovery attempts
- Successful recoveries
- Failed recoveries requiring escalation
- Average recovery time
- Time to detection (failure ‚Üí detection)
- Time to recovery (detection ‚Üí restored)
- Recovery success rate by component
- Most common failure types

**Recovery Logging**:
```
[TIMESTAMP] [RECOVERY] Detected: &lt;failure_type&gt; on &lt;component&gt;
[TIMESTAMP] [RECOVERY] Diagnosis: &lt;root_cause&gt;
[TIMESTAMP] [RECOVERY] Strategy: &lt;recovery_strategy&gt;
[TIMESTAMP] [RECOVERY] Action: &lt;recovery_action_taken&gt;
[TIMESTAMP] [RECOVERY] Result: &lt;success|failure&gt; (&lt;duration&gt;s)
[TIMESTAMP] [RECOVERY] Post-check: &lt;verification_results&gt;
```

**Log Files**:
- Recovery log: `logs/recovery.log`
- Escalation log: `logs/escalation.log`
- Diagnostic reports: `diagnostics/reports/recovery-&lt;timestamp&gt;.txt`

## Decision Keywords

You MUST use these exact decision keywords to signal completion states:

- **recovery_successful**: Successfully detected and recovered from failure
  - Use after: Failure detected, recovery executed, component restored, verification passed
  - Include: Failure type, recovery strategy used, recovery time, verification results
  - Example: &quot;Recovered from daemon crash in 25 seconds using restart strategy&quot;

- **recovery_failed**: Recovery attempted but failed, escalation required
  - Use after: Recovery strategies exhausted, component still failing, manual intervention needed
  - Include: Failure type, recovery attempts made, failure reasons, escalation actions
  - Example: &quot;Failed to recover pool after 3 restart attempts, escalating to user notification&quot;

- **environment_reset**: Test environment reset successfully completed
  - Use after: All components stopped, data cleared, configs regenerated, components restarted, environment verified
  - Include: Reset type (soft/data/full/config), components restarted, verification status
  - Example: &quot;Full environment reset completed - daemon, pool, and miner running with clean state&quot;

- **error**: General error during recovery operations
  - Use for: Cannot access components, permission issues, unknown failures, system errors
  - Include: Error description, affected components, diagnostic information, suggested actions
  - Example: &quot;Cannot stop pool process - insufficient permissions&quot;

## Recovery Workflows

### Workflow 1: Daemon Crash Recovery
1. Detect daemon not running (process check or RPC failure)
2. Check debug.log for crash reason
3. Remove stale lock if present
4. Restart bitcoind
5. Wait for initialization (15 seconds)
6. Verify RPC accessible
7. Check daemon block height and status
8. Return DECISION: recovery_successful

### Workflow 2: Pool Disconnection Recovery
1. Detect pool not running or disconnected from daemon
2. Check pool logs for error cause
3. Verify daemon is accessible (RPC test)
4. If daemon down: recover daemon first
5. Stop pool gracefully (taskkill.exe)
6. Restart pool from working directory
7. Wait for Stratum initialization (10 seconds)
8. Verify port listening and daemon connection
9. Return DECISION: recovery_successful

### Workflow 3: Cascading Failure Recovery
1. Detect multiple component failures
2. Stop all components (miners, pool, daemon)
3. Diagnose root cause from logs
4. Clear stale locks if present
5. Restart in dependency order: daemon ‚Üí pool ‚Üí miners
6. Verify each component before starting next
7. Confirm full stack operational
8. Return DECISION: recovery_successful

### Workflow 4: Full Environment Reset
1. Stop all components gracefully
2. Force stop any remaining processes
3. Clean regtest data directory
4. Clean pool data and logs
5. Remove all lock files
6. Restart daemon with fresh regtest
7. Generate 101 blocks for funding
8. Restart pool and verify daemon connection
9. Restart miners and verify shares submitted
10. Return DECISION: environment_reset

### Workflow 5: RPC Failure Recovery
1. Detect RPC connection or authentication failure
2. Test daemon process running
3. Test RPC port accessible
4. Verify credentials in config
5. If daemon down: restart daemon
6. If auth error: fix credentials and restart
7. If timeout: check daemon responsiveness
8. Test RPC multiple times for stability
9. Return DECISION: recovery_successful

### Workflow 6: Stale Lock Cleanup
1. Find lock files in known locations
2. For each lock: validate owning process exists
3. If process not running: lock is stale
4. Safely remove stale lock
5. Verify lock removed
6. Document lock removal in log
7. Attempt to start component
8. Return DECISION: recovery_successful

## Best Practices

- **Detect early**: Monitor continuously, catch failures quickly
- **Diagnose first**: Understand root cause before recovery
- **Gentle recovery**: Try soft recovery before hard reset
- **Verify thoroughly**: Confirm recovery before declaring success
- **Log everything**: Document all recovery attempts and outcomes
- **Sequential recovery**: Recover dependencies first (daemon before pool)
- **Escalate appropriately**: Don&#039;t retry infinitely, know when to escalate
- **Preserve data**: Backup logs before cleanup operations
- **Test recovery**: Verify component functionality, not just process running
- **Learn from failures**: Track patterns to prevent recurrence

## Integration with Other Agents

**Coordinate with**:
- **bitcoin_daemon_manager**: For daemon restart operations
- **pool_server_manager**: For pool restart and configuration
- **network_monitor**: For failure detection signals
- **stratum_monitor**: For pool disconnection alerts
- **log_analyzer**: For error pattern detection
- **diagnostics_agent**: For health check data and reports
- **miner_manager**: For miner process management

**Recovery Triggers**:
- Receive failure events from monitoring agents
- Periodic health checks detect issues
- User manual recovery request
- Automatic retry after temporary failures
- Escalation from other agents

**Recovery Notifications**:
- Notify monitoring agents when recovery complete
- Update health status in diagnostics
- Signal dependent components to reconnect
- Log recovery events for analysis
- Trigger alerts if escalation needed

Always provide clear, actionable feedback at each recovery step. When recovery completes successfully, use the recovery_successful decision keyword. When recovery fails and requires escalation, use recovery_failed. For full environment resets, use environment_reset. When errors prevent recovery operations, use error.

=== ROUTING DECISION REQUIRED ===
After your response, you MUST choose exactly ONE decision from:
- recovery_successful: Infrastructure recovered successfully
- recovery_failed: Recovery failed after max attempts
- environment_reset: Full environment reset completed

**CRITICAL**: Your VERY LAST LINE must be exactly:
DECISION: [ONE_OF_THE_ABOVE_CHOICES]
Example: DECISION: recovery_successful
Do NOT add explanations after the decision keyword.
</pre>
        </div>
      </div>
      

      
      <div class="output-section">
        <div class="section-label">üì§ AGENT OUTPUT <span class="char-count">(3,467 characters)</span></div>
        <button class="collapsible" data-target="output_handle_recovery_2">Click to expand output from error_recovery_agent</button>
        <div class="collapsible-content" id="output_handle_recovery_2">
          <pre class="code-content">## RECOVERY FAILURE REPORT

### Infrastructure State
- **Bitcoin Daemon**: Running in WSL, RPC functional (verified via curl)
- **CoiniumServ Pool**: Running in WSL via Mono, Stratum functional  
- **Connectivity**: Pool‚ÜíDaemon RPC connection FAILING

### Failure Type
**RPC Connection Failure** - Mono networking incompatibility in WSL environment

### Recovery Attempts

**Attempt 1: Pool Process Restart**
- Action: Stopped and restarted CoiniumServ pool process
- Result: FAILED - Connection refused errors persist
- Duration: 15 seconds

**Attempt 2: Daemon Host Configuration Change**
- Action: Changed pool config from `host: &quot;127.0.0.1&quot;` to `host: &quot;172.22.45.9&quot;` (WSL IP)
- Restarted pool with new configuration
- Result: FAILED - Connection refused errors persist
- Duration: 20 seconds

**Attempt 3: Verification of Daemon Accessibility**
- Verified daemon RPC working via curl: SUCCESS
- Verified daemon listening on ports: SUCCESS  
- Confirmed credentials correct: SUCCESS
- Mono socket connection: FAILED

### Root Cause

**Mono/.NET Framework Networking Incompatibility in WSL**

The pool uses `System.Net.HttpWebRequest` and `System.Net.Sockets.Socket` which fail at the OS socket layer when Mono runs in WSL:

```
Error: ConnectFailure (Connection refused)
  at System.Net.Sockets.SocketAsyncResult.CheckIfThrowDelayedException()
  at System.Net.Sockets.Socket.EndConnect()
  at System.Net.WebConnection.Connect()
```

This is a known Mono-on-WSL limitation where the .NET networking stack cannot reliably connect to localhost services due to Windows/Linux network stack translation issues.

### Evidence
- Daemon RPC accessible via native Linux curl: ‚úì
- Daemon RPC inaccessible via Mono HttpWebRequest: ‚úó  
- Error occurs at socket connection level (not HTTP/auth layer)
- Both 127.0.0.1 and WSL IP (172.22.45.9) fail identically

### Escalation Reason

**Cannot recover automatically** - requires architectural changes:

**Option A**: Install Windows-native Bitcoin Core
- Download and install bitcoind.exe for Windows
- Run daemon natively on Windows (not WSL)
- Mono can connect to Windows localhost more reliably
- Requires manual software installation

**Option B**: Run pool natively on Windows  
- Compile/run CoiniumServ.exe on Windows .NET Framework
- Bypass WSL Mono entirely
- Requires build environment change

**Option C**: Use network bridge/proxy
- Configure socat or similar to bridge Mono‚ÜíDaemon
- Complex networking setup
- Not recommended for production

### Recommended Action

1. Install Bitcoin Core for Windows from bitcoin.org
2. Configure Windows bitcoind with regtest mode:
   - Create `%APPDATA%\Bitcoin\bitcoin.conf` with RPC settings
   - Start: `bitcoind.exe -regtest -daemon`
3. Update pool config to connect to Windows localhost
4. Restart pool - should connect successfully

### Current Infrastructure Status

| Component | Status | Details |
|-----------|--------|---------|
| Bitcoin Daemon (WSL) | Running | RPC port 18443, verified functional |
| CoiniumServ Pool | Running | Stratum port 3333, cannot reach daemon |
| Pool-Daemon RPC | **FAILED** | Mono networking incompatibility |
| Mining Software | Not Installed | Blocked by pool connectivity issue |

### Recovery Failure Classification

**Type**: Architectural/Environment Incompatibility  
**Severity**: Blocker - prevents core pool functionality  
**Auto-Recovery**: Not possible  
**Manual Intervention Required**: Yes

---

DECISION: recovery_failed</pre>
        </div>
      </div>
      

      

      
      <div class="routing-info">
        <div class="routing-decision">üîÄ Routing Decision: RECOVERY_FAILED</div>
        <div style="font-size: 0.9em; color: #555; margin-top: 5px;">Decision &quot;RECOVERY_FAILED&quot; matched connection condition</div>
        <div style="margin-top: 10px; font-weight: bold;">‚Üí Next Stage: <strong>orchestrate</strong></div>
      </div>
      
    </div>

    <div class="stage running">
      <div class="stage-header">
        <div>
          <div class="stage-title">Infrastructure Orchestrator</div>
          <div style="color: #6c757d; font-size: 0.9em; margin-top: 5px;">Analyzes infrastructure needs, delegates tasks to specialized agents, adapts to failures, learns from outcomes</div>
        </div>
        <span class="stage-badge badge-running">running</span>
      </div>

      <div class="stage-meta">
        <div class="meta-item">
          <span class="meta-label">Agent:</span>
          <span class="meta-value">infrastructure_orchestrator</span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Type:</span>
          <span class="meta-value"></span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Duration:</span>
          <span class="meta-value">In progress...</span>
        </div>
        <div class="meta-item">
          <span class="meta-label">Execution #:</span>
          <span class="meta-value">3</span>
        </div>
        
        
      </div>

      

      

      

      
    </div>
    </div>

    
  </div>

  <script>
    // Interactive collapsible sections
    document.addEventListener('DOMContentLoaded', function() {
      const collapsibles = document.querySelectorAll('.collapsible');

      collapsibles.forEach(button => {
        button.addEventListener('click', function() {
          this.classList.toggle('active');
          const targetId = this.getAttribute('data-target');
          const content = document.getElementById(targetId);

          if (content) {
            content.classList.toggle('active');
          }
        });
      });

      // Add "Expand All" / "Collapse All" buttons
      const header = document.querySelector('.header');
      if (header && collapsibles.length > 0) {
        const controlsDiv = document.createElement('div');
        controlsDiv.style.marginTop = '20px';

        const collapseAllBtn = document.createElement('button');
        collapseAllBtn.textContent = 'Collapse All Sections';
        collapseAllBtn.style.cssText = 'padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px; font-weight: bold;';
        collapseAllBtn.addEventListener('click', function() {
          collapsibles.forEach(btn => {
            btn.classList.add('active');
            const targetId = btn.getAttribute('data-target');
            const content = document.getElementById(targetId);
            if (content) content.classList.add('active');
          });
        });

        const expandAllBtn = document.createElement('button');
        expandAllBtn.textContent = 'Expand All Sections';
        expandAllBtn.style.cssText = 'padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;';
        expandAllBtn.addEventListener('click', function() {
          collapsibles.forEach(btn => {
            btn.classList.remove('active');
            const targetId = btn.getAttribute('data-target');
            const content = document.getElementById(targetId);
            if (content) content.classList.remove('active');
          });
        });

        controlsDiv.appendChild(collapseAllBtn);
        controlsDiv.appendChild(expandAllBtn);
        header.appendChild(controlsDiv);
      }
    });
  </script>
</body>
</html>