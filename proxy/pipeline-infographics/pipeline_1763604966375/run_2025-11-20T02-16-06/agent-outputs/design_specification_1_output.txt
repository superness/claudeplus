Now I have enough context to create a comprehensive plan for building the error_recovery_agent.

---

## UNDERSTANDING
The user wants me to build a comprehensive error_recovery_agent based on section 2.4 of the MINING_CYCLE_AUTOMATION_PLAN.md. The agent needs to detect and recover from common failures in the mining infrastructure including daemon crashes, RPC failures, pool disconnections, miner errors, stale locks, and test environment resets. The output should be a complete JSON agent specification file written to `/mnt/c/github/claudeplus/agents/error_recovery_agent.json`.

## APPROACH
1. Review section 2.4 of MINING_CYCLE_AUTOMATION_PLAN.md to understand the error_recovery_agent requirements
2. Examine existing error_recovery_agent.json from the SuperCoinServ project to understand the current structure and capabilities
3. Analyze related agents (bitcoin_daemon_manager, pool_server_manager, network_monitor, stratum_monitor, diagnostics_agent, log_analyzer) to understand their error handling patterns and dependencies
4. Design a comprehensive error recovery agent that includes:
   - Detection mechanisms for each failure type
   - Recovery strategies and procedures
   - Integration with existing agents
   - Proper RPC endpoint definitions
   - Error handling escalation paths
   - Logging and metrics
5. Create the complete JSON specification following the established agent schema patterns observed in other agents
6. Write the JSON file to the specified location

## STEPS
1. **Read and analyze section 2.4** - Use Grep to extract full section 2.4 content from MINING_CYCLE_AUTOMATION_PLAN.md (lines 378-449)
2. **Examine existing agent structure** - Already read error_recovery_agent.json from SuperCoinServ to see current implementation (lines 1-34)
3. **Review related agents** - Already read bitcoin_daemon_manager, diagnostics_agent, network_monitor, stratum_monitor, pool_server_manager, miner_manager for patterns
4. **Identify recovery procedures needed**:
   - Daemon crash detection and restart procedure
   - RPC connection failure recovery
   - Pool server disconnection handling
   - Miner process restart logic
   - Stale lock cleanup procedures
   - Test environment reset capabilities
5. **Define agent structure** with:
   - agent_name, agent_type, group, version, description
   - Configuration section with recovery parameters (timeouts, retry limits, backoff strategies)
   - Responsibilities array covering all 7 requirements
   - Dependencies on bitcoin_daemon_manager, pool_server_manager, miner_manager, network_monitor, stratum_monitor, log_analyzer, diagnostics_agent
   - RPC endpoints for recovery operations, status checks, environment reset
   - Outputs including events (recovery_successful, recovery_failed, environment_reset, error) and metrics
   - Error handling strategies for each failure type
   - Logging configuration
   - Validation rules
6. **Create comprehensive capabilities section** including:
   - Process monitoring (ps, systemctl status checks)
   - RPC connectivity testing
   - Connection state validation
   - Lock file detection and cleanup
   - Component restart sequences
   - Environment cleanup procedures
7. **Define recovery strategies**:
   - Daemon crash: Check process, restart with bitcoind, verify RPC
   - RPC failures: Test connection, restart daemon if needed, validate auth
   - Pool disconnections: Check pool process, restart pool, verify stratum port
   - Miner errors: Stop miner, clear state, restart with config
   - Stale locks: Find .lock files, validate ownership, remove safely
   - Environment reset: Stop all, clean data dirs, regenerate configs, restart all
8. **Write JSON file** to `/mnt/c/github/claudeplus/agents/error_recovery_agent.json` using Write tool
9. **Verify output** by reading the created file to ensure proper JSON formatting

## TEST_CONSIDERATIONS
The plan addresses the test scenarios through:
1. **Daemon crash detection**: Include process monitoring checks, RPC ping tests, and automatic restart procedures
2. **RPC failure recovery**: Define connection testing, authentication validation, timeout handling, and reconnection logic
3. **Pool disconnection handling**: Implement stratum port checks, pool process monitoring, and restart sequences
4. **Miner error restart**: Create miner process monitoring, error log parsing, and clean restart procedures
5. **Stale lock clearing**: Define lock file discovery, validation, and safe removal procedures
6. **Environment reset**: Comprehensive cleanup including stopping all services, cleaning directories, regenerating configs, and ordered restart
7. **Decision routing**: Implement all 4 required decisions (recovery_successful, recovery_failed, environment_reset, error) in the outputs.events section
8. **Edge cases**: Handle scenarios where recovery fails multiple times (escalation), partial failures, and conflicting states

## EVIDENCE
Will provide the following evidence to validate the work:
1. Complete JSON file content showing all sections properly structured
2. Verification that all 7 requirements are addressed in responsibilities and capabilities
3. Confirmation that all 4 decision types (recovery_successful, recovery_failed, environment_reset, error) are present in outputs
4. RPC endpoint definitions for triggering recovery, checking status, and resetting environment
5. Dependencies list includes all relevant agents (bitcoin_daemon_manager, pool_server_manager, miner_manager, network_monitor, stratum_monitor, log_analyzer, diagnostics_agent)
6. Error handling section covers each failure type with specific strategies
7. Recovery procedures mapped to each requirement from section 2.4
8. File successfully written to the specified path

## CONFIDENCE
High - The task is well-defined with clear requirements from section 2.4 of the plan. There are excellent reference examples from existing agent JSON files showing the expected structure and patterns. The requirements (7 capabilities, 4 decision types) are specific and measurable. The file location is provided explicitly. All necessary information is available to create a comprehensive agent specification that follows established patterns and meets all stated requirements.

[DECISION: design_complete]