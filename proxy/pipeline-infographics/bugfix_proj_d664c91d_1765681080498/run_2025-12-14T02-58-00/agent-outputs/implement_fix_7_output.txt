Perfect! The fix has been applied. Now let me provide my summary.

---

**Changes Made**:

File: `/mnt/c/github/40kgw/output/client/src/combat/LootVisualization.ts`
- **Line 338**: Moved `scene.remove(this.group)` to execute BEFORE material disposals (previously line 353)
- **Lines 336-337**: Added comment explaining why scene removal must happen first
- **Lines 341-356**: Material disposal code remains unchanged, but now executes after scene removal

**Why This Fixes It**:

The bug was a race condition between material disposal and the render loop:

1. **Before**: When a loot orb was picked up or timed out, `dispose()` would:
   - Dispose all 4-5 materials (coreMesh, glowMesh, glowRing, particles, optional beamLine)
   - THEN remove the group from the scene
   - In the gap between these steps, the game loop continues at 60fps
   - Three.js WebGLRenderer tries to render the loot orb meshes
   - Shader uniform access fails because materials have been disposed
   - **Result**: `TypeError: Cannot read properties of undefined (reading 'value')`

2. **After**: Now `dispose()`:
   - Removes group from scene FIRST (line 338)
   - Then safely disposes materials (lines 341-356)
   - Meshes are no longer in the render pipeline when materials are disposed
   - No more shader access errors

This is the same fix pattern that was applied to Enemy.ts:1645 - the key principle is **"remove from scene before disposing GPU resources"**.

**Testing Suggestion**:

1. Start a game and kill an enemy to spawn loot
2. Wait for the loot orb to appear
3. Pick up the loot (walk close or click on it)
4. Verify no Three.js errors appear in console
5. Kill multiple enemies to spawn multiple loot orbs
6. Pick them all up in quick succession
7. Verify rendering remains stable without crashes

The fix should eliminate the `refreshUniformsCommon` errors that occurred after enemy death when loot was spawned and then disposed.

DECISION: fix_implemented