Excellent! Now I have identified the root cause. Let me compile my findings.

---

**Investigation Summary**:

I have successfully traced the bug from the Three.js error back to the Enemy disposal sequence. The issue occurs when an enemy dies and the disposal method tries to clean up resources while the mesh is still being rendered. The health bar container and its materials are disposed BEFORE the mesh is removed from the scene, causing shader uniform access errors during the render loop.

**Root Cause**:

**File**: `/mnt/c/github/40kgw/output/client/src/game/entities/Enemy.ts`

**Line(s)**: 1644-1659 (dispose method)

**Issue**: Resource disposal timing bug - materials are disposed while mesh is still in the scene

**Why**: 

The `dispose()` method has a critical flaw in its execution order:

1. **Lines 1644-1657**: The code traverses `this.mesh` and disposes ALL child geometries and materials
   - This includes the `healthBarContainer` which was added at line 1060
   - The health bar contains THREE.Mesh objects with MeshBasicMaterial (lines 986-1025)
   - These materials are disposed immediately via `child.material.dispose()` (line 1650)

2. **Line 1659**: AFTER materials are disposed, the mesh is removed from the scene

3. **The Problem**: Between lines 1657 and 1659, there's a window where:
   - Materials have been disposed (their GPU resources freed, uniforms cleared)
   - The mesh is STILL in the scene graph
   - The game render loop continues running (Game.ts:940)
   - Three.js WebGLRenderer tries to render the mesh
   - `refreshUniformsCommon` attempts to access material uniforms
   - Uniforms have undefined `.value` properties because material was disposed
   - **Result**: `TypeError: Cannot read properties of undefined (reading 'value')`

4. **Why it manifests after enemy death**: 
   - Enemy dies â†’ death animation plays for several seconds
   - During animation, enemy mesh remains in scene and continues rendering
   - Eventually `EntityManager.removeEnemy()` calls `enemy.dispose()` (line 235)
   - The dispose happens while the render loop is active
   - The disposed materials cause immediate shader crashes on the next frame

**Fix Strategy**:

**Primary Fix**: Remove mesh from scene BEFORE disposing materials

Change the order in the `dispose()` method:
```typescript
dispose(): void {
  this.buffIndicator?.dispose();
  
  // FIRST: Remove from scene to prevent rendering during disposal
  this.scene.remove(this.mesh);
  
  // THEN: Dispose resources (now safe because mesh is no longer rendered)
  this.mesh.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      child.geometry.dispose();
      if (Array.isArray(child.material)) {
        child.material.forEach((m) => m.dispose());
      } else {
        child.material.dispose();
      }
    }
    if (child instanceof THREE.Points) {
      child.geometry.dispose();
      (child.material as THREE.Material).dispose();
    }
  });
}
```

**Alternative approach** (if removal before disposal causes issues):
Explicitly dispose health bar before traversal to ensure it's handled separately.

**Risks/Considerations**:

1. **Low Risk**: Moving `scene.remove()` before disposal is standard practice in Three.js
   - Once removed from scene, the mesh won't be rendered
   - Materials can be safely disposed without render conflicts
   - This is actually the recommended pattern in Three.js documentation

2. **Potential side effect**: If any code relies on the mesh being in the scene during disposal callbacks, that code would break
   - However, no such code was found in the codebase
   - The buff indicator disposal (line 1642) is independent

3. **Verification needed**: Ensure death animation completes before disposal
   - The death animation code (lines 1304-1426) appears to run independently
   - Death particles are cleaned up separately (lines 1420-1424)
   - Animation should complete before `dispose()` is called by EntityManager

4. **No other side effects expected**: The fix is surgical and focused on the disposal sequence

DECISION: root_cause_found