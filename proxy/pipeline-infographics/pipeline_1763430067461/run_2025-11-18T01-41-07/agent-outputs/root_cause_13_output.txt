Now I have enough information to create the root cause analysis. The code clearly shows:

1. **SaveGameManager.js** has `serializeShipFitting()` (lines 657-709) and `deserializeShipFitting()` (lines 714-774) methods
2. These methods ARE being called in the save/load flow
3. The serialization captures fitted items correctly (lines 670-673)
4. The deserialization attempts to restore fitted items (lines 752-765)
5. **BUT** - the fitted items are being restored by calling `fitItem()` which requires items in inventory
6. The problem is the restoration logic unfits all items first (lines 743-749), adding them to inventory, then tries to refit them
7. However, if the items weren't in the inventory in the first place (they were only fitted), they get lost

The actual root cause is more subtle - let me check if the fitItem() method requires items to be in cargo or inventory:

Looking at ShipFittingManager.js lines 185-228, the `fitItem()` method:
- Checks inventory first (lines 196-206)
- If not in inventory, tries to remove from cargo (lines 203-206)
- If item not found, returns error "Item not available in inventory or cargo"

So the bug is: **The deserializeShipFitting() method tries to restore fitted items by calling fitItem(), but fitItem() requires the items to exist in inventory or cargo first. However, the serialization doesn't guarantee these items are in inventory - they might only exist as fitted items. When the game loads, it tries to fit items that don't exist in inventory, and the fitItem() calls fail silently.**

```json
{
  "rootCause": "Ship fitted items are not persisting because the restoration logic fails to provide items to the inventory before attempting to refit them. The deserializeShipFitting() method calls fitItem() to restore fitted items, but fitItem() requires items to exist in inventory or cargo first. The serialization saves fitted items correctly, but doesn't ensure these items are available in inventory during restoration, causing fitItem() to fail silently and leave slots empty.",
  "affectedFiles": [
    {
      "path": "/mnt/c/github/superstarships/js/systems/SaveGameManager.js",
      "lineNumbers": [752, 753, 754, 755, 756, 757, 758, 759],
      "currentCode": "for (const slotType of ['high', 'mid', 'low', 'rig']) {\n    if (savedSlots[slotType]) {\n        savedSlots[slotType].forEach((item, index) => {\n            if (item && item.itemId) {\n                const result = fittingManager.fitItem(shipId, item.itemId, slotType, index);\n                if (!result.success) {\n                    console.warn(`Failed to restore fitted item ${item.itemId} to ${slotType}[${index}]:`, result.error);\n                }\n            }\n        });\n    }\n}",
      "problem": "Calls fitItem() without ensuring the item exists in inventory first. fitItem() requires items in inventory/cargo, but serialized fitted items are not guaranteed to be in inventory during restoration."
    },
    {
      "path": "/mnt/c/github/superstarships/js/systems/ShipFittingManager.js",
      "lineNumbers": [185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206],
      "currentCode": "// Remove item from inventory if present\nconst inventoryQuantity = this.playerInventory.get(itemId) || 0;\nif (inventoryQuantity > 0) {\n    this.playerInventory.set(itemId, inventoryQuantity - 1);\n    if (this.playerInventory.get(itemId) === 0) {\n        this.playerInventory.delete(itemId);\n    }\n} else {\n    // Try to remove from cargo\n    if (!this.resourceManager.removeResource(itemId, 1)) {\n        return { success: false, error: 'Item not available in inventory or cargo' };\n    }\n}",
      "problem": "fitItem() requires items to exist in inventory or cargo before fitting. Returns error if item not found, which prevents restoration of fitted items during game load."
    },
    {
      "path": "/mnt/c/github/superstarships/js/systems/SaveGameManager.js",
      "lineNumbers": [690, 691, 692, 693, 694, 695, 696, 697, 698, 699],
      "currentCode": "const serializedInventory = {};\nfor (const [itemId, quantity] of fittingManager.playerInventory) {\n    // Add the fitted count back so we have the total when restoring\n    const fittedCount = fittedItemCounts.get(itemId) || 0;\n    const totalQuantity = quantity + fittedCount;\n    if (totalQuantity > 0) {\n        serializedInventory[itemId] = totalQuantity;\n    }\n}",
      "problem": "Only serializes items that are already in playerInventory. Fitted items that were ONLY fitted (never in inventory) are not included in serializedInventory, so they're not available during restoration."
    }
  ],
  "executionFlow": [
    "Game loads â†’ SaveGameManager.loadGame() called",
    "deserializeShipFitting(saveData.shipFitting) called",
    "Inventory restored from saveData.shipFitting.playerInventory",
    "All current fitted items unfitted (added to inventory)",
    "Attempts to refit items from saveData.shipFitting.currentFitting.slots",
    "For each fitted item: calls fitItem(shipId, itemId, slotType, index)",
    "fitItem() checks playerInventory for item",
    "If item not in inventory, checks cargo (resourceManager)",
    "If item not in cargo, returns {success: false, error: 'Item not available in inventory or cargo'}",
    "Warning logged but slot remains empty (null)",
    "Ship loads with empty slots - fitted items lost"
  ],
  "whyItHappens": "The serialization logic attempts to include fitted items in the inventory count (lines 690-699), but it only iterates over items already in playerInventory Map. Fitted items that were never in playerInventory (e.g., purchased and immediately fitted from station, or fitted directly from cargo) are not included in the serialized inventory. During restoration, these items don't exist in inventory, so fitItem() fails and the slots remain empty. The code assumes all fitted items will be in playerInventory after unfitting, but the unfitting happens AFTER inventory restoration, creating a mismatch.",
  "proposedFix": "1. In serializeShipFitting() (SaveGameManager.js:690-699): Iterate over fitted items FIRST to build the complete list of items needed, then merge with playerInventory. This ensures all fitted items are included in serializedInventory regardless of whether they're currently in playerInventory.\n\n2. Alternative fix: In deserializeShipFitting() (SaveGameManager.js:752-765): Before calling fitItem(), add each item to playerInventory temporarily if it's not already there. This ensures fitItem() can find the item.\n\n3. Best fix: Create a new method in ShipFittingManager called 'restoreFittedItem()' that bypasses the inventory check and directly sets the slot, only to be used during save/load restoration. This avoids the inventory requirement entirely for restoration purposes."
}
```

DECISION: root_cause_found