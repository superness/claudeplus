I've found the root cause. Let me examine the key methods more closely to confirm my analysis.

**Investigation Summary**:

I've identified the root cause of the bug where the AI controls both players for multiple turns after the human makes their first move.

**Root Cause**:

File: `client/game.js`
Line(s): 1293-1294, 1206-1213
Issue: Race condition between `updateUI()` and `scheduleAIMove()` when multi-jump occurs

The bug occurs due to a critical logic flaw in how the `executeMove()` and `executeAIMove()` methods interact:

**Why this causes the bug:**

1. When the human player (Red) makes a move at line 1168, `executeMove()` is called
2. If it's not a multi-jump continuation, line 1208 calls `this.turnSystem.endTurn()` which switches to black
3. Line 1211-1213 then schedules the AI move for black
4. The AI move executes via `executeAIMove()` (line 1237)
5. After AI completes its move (non-multi-jump), line 1293 calls `this.turnSystem.endTurn()` which switches back to red
6. Line 1295 calls `this.updateUI()`
7. **THE BUG**: `updateUI()` at line 1299 does NOT check if the current player is the human or AI before setting status messages

However, looking more carefully, the actual root cause is in `executeAIMove()` lines 1286-1296:

When AI finishes its turn:
- Line 1293: `this.turnSystem.endTurn()` - switches `currentPlayer` to `'red'`
- Line 1294: `this.aiThinking = false`
- Line 1295: `this.updateUI()`

But the **real issue** is that `executeAIMove()` lacks a guard check to verify it's still the AI's turn before executing. Since `aiThinking` is the only guard, and `scheduleAIMove()` at line 1227 only checks `if (this.aiThinking) return`, there's a window where the flag could be false while the turn hasn't properly transferred.

**ACTUAL ROOT CAUSE FOUND:**

After `executeAIMove()` completes and calls `endTurn()` at line 1293, the `aiThinking` is set to `false` at line 1294. But the `setTimeout` callbacks from `scheduleAIMove()` (line 1232) may have already been queued. If multiple rapid inputs or a race condition occurs, `scheduleAIMove()` could be invoked again before the flag is properly set.

More critically: Looking at `executeMove()` (the human move handler), line 1211-1213 schedules an AI move whenever `this.turnSystem.currentPlayer === 'black'`. But `executeAIMove()` doesn't verify that the current player is still black before executing.

If `executeAIMove()` is called with `multiJumpPiece = null` when it's red's turn, `aiSystem.chooseBestMove()` at line 1245 calls `getAllMoves()` at line 1051 which gets moves for BLACK (hardcoded at line 855). This returns valid moves, and the AI executes them even though it's red's turn in `turnSystem`.

**The actual sequence:**
1. Human moves → endTurn() → currentPlayer = black → scheduleAIMove()
2. AI executes → endTurn() → currentPlayer = red → aiThinking = false
3. BUT if there's still a pending setTimeout from a previous scheduleAIMove(), it fires
4. The second scheduleAIMove() sees aiThinking = false, sets it to true, and calls executeAIMove()
5. executeAIMove() doesn't check currentPlayer, so it executes a move for black pieces even though currentPlayer is red
6. This corrupts the game state

**Fix Strategy**:

Add a guard check at the beginning of `executeAIMove()` to verify it's actually the AI's turn:

```javascript
executeAIMove(multiJumpPiece = null) {
    // CRITICAL: Verify it's actually the AI's turn before executing
    if (this.turnSystem.currentPlayer !== 'black') {
        this.aiThinking = false;
        return;
    }
    // ... rest of method
}
```

This ensures that even if stale setTimeout callbacks fire, the AI won't execute moves when it's not black's turn.

**Risks/Considerations**:

1. **Minimal risk** - This fix adds a guard clause that prevents execution when incorrect, with no side effects
2. The guard returns early and resets `aiThinking`, which is the correct behavior
3. No existing functionality is altered when the game state is correct
4. The check happens before any board state modification

DECISION: root_cause_found