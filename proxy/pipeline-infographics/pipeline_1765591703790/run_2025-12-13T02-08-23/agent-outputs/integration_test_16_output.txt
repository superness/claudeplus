Now I have a clear understanding. The game relies on browser APIs (THREE.js, HTMLCanvasElement) which means we need proper browser testing infrastructure. The previous stage verified code paths via static analysis, but for **actual gameplay tests**, we need either:

1. **Test hooks** that expose internal game state for programmatic testing
2. **Playwright/browser automation** for full E2E testing

Neither exists. I need to request the automation infrastructure.

## Automation Request

### What I Need

1. **Test Hooks Module** (`client/src/tests/test-hooks.ts`)
   - Exposes internal game state without DOM dependencies
   - Functions needed:
     - `spawnTestEnemy(type: string, x: number, z: number)` - Create enemy at position
     - `getEnemyHealth(enemyId: string)` - Read enemy current health
     - `useSkill(slotIndex: number)` - Trigger skill execution programmatically
     - `selectEnemy(enemyId: string)` - Set target
     - `getPlayerEnergy()` - Read player energy
     - `getPlayerHealth()` - Read player health
     - `getSkillCooldown(slotIndex: number)` - Check cooldown state

2. **Playwright Setup** (for full browser testing)
   - Install `@playwright/test`
   - Basic test spec that:
     - Loads the game in browser
     - Waits for scene to render
     - Simulates key presses for combat
     - Validates UI updates

3. **Jest/Vitest Unit Test Setup** (for headless combat logic testing)
   - Mock THREE.js scene/camera
   - Test CombatValidator, CombatSystem, DamageCalculation in isolation

### Why

The previous stage (`test_feature`) performed **static code analysis** and verified integration paths exist. But we need to run **actual gameplay tests** to:
- Verify damage is actually applied when skills execute
- Confirm enemy health decreases correctly
- Test skill cooldowns prevent re-use
- Validate energy is consumed on skill use
- Check that dead enemies are properly handled

Without test hooks or browser automation, we cannot execute these runtime validations.

### Suggested Implementation

For test hooks, inject them at Game initialization:

```typescript
// client/src/tests/test-hooks.ts
import { Game } from '../game/Game';

export function installTestHooks(game: Game) {
  (globalThis as any).__TEST_HOOKS__ = {
    getEntityManager: () => game.getEntityManager(),
    getCombatManager: () => game.getCombatManager(),
    spawnTestEnemy: (type: string, x: number, z: number) => {
      return game.getEntityManager().spawnEnemy(type, x, z);
    },
    // ... etc
  };
}
```

This requires Game class to expose getters for internal systems (currently private).

DECISION: needs_automation