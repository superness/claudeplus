Now I understand! Let me trace through the exact execution flow to identify the root cause:

```json
{
  "rootCause": "Ship velocity is initialized as THREE.Vector3 object, but physics update loop expects plain object structure. When ShipFittingManager.syncStatsFromFitting() modifies physics properties, it corrupts the velocity object's internal state.",
  "affectedFiles": [
    {
      "path": "/mnt/c/github/superstarships/js/physics/ShipPhysics.js",
      "lineNumbers": [36, 38, 161, 162, 163],
      "currentCode": "// Line 36-38:\nthis.velocity = typeof THREE !== 'undefined' ? new THREE.Vector3(0, 0, 0) : { x: 0, y: 0, z: 0 };\n\n// Line 161-163:\nthis.velocity.x += (this.targetVelocity.x - this.velocity.x) * factor;\nthis.velocity.y += (this.targetVelocity.y - this.velocity.y) * factor;\nthis.velocity.z += (this.targetVelocity.z - this.velocity.z) * factor;",
      "problem": "Velocity is a THREE.Vector3 object with .x, .y, .z properties AND internal array storage. When physics tries to modify velocity.x/y/z directly, it may be modifying the wrong internal representation."
    },
    {
      "path": "/mnt/c/github/superstarships/js/entities/Ship.js",
      "lineNumbers": [76, 88, 92, 96, 99],
      "currentCode": "syncStatsFromFitting() {\n    if (!this.isPlayer) return;\n    const fittingManager = window.simulator?.shipFittingManager;\n    if (!fittingManager) return;\n    const fitting = fittingManager.getPlayerShipFitting();\n    if (!fitting || !fitting.currentStats) return;\n    const stats = fitting.currentStats;\n    // Update physics stats from fitting\n    const maxVel = (stats.maxSpeed && stats.maxSpeed > 0) ? stats.maxSpeed : stats.maxVelocity;\n    if (maxVel !== undefined && maxVel > 0) {\n        this.physics.maxVelocity = maxVel;\n    }\n    if (stats.agility !== undefined) {\n        this.physics.agility = stats.agility;\n        this.physics.timeConstant = stats.agility / 500000;\n    }",
      "problem": "When syncStatsFromFitting() modifies this.physics.maxVelocity and this.physics.timeConstant, it may be triggering side effects that corrupt the velocity Vector3 object"
    }
  ],
  "executionFlow": [
    "1. Game loads → Ship created with velocity = new THREE.Vector3(0, 0, 0)",
    "2. Ship fitting has afterburner → syncStatsFromFitting() called",
    "3. syncStatsFromFitting() modifies physics.maxVelocity and physics.timeConstant",
    "4. Physics update loop runs: applyExponentialAcceleration()",
    "5. Line 161: this.velocity.x += ... tries to modify Vector3.x property",
    "6. THREE.Vector3 may have internal state corruption when .x/.y/.z modified directly",
    "7. Velocity becomes frozen - modifications to .x/.y/.z no longer update the vector",
    "8. Ship position never updates because velocity is frozen"
  ],
  "whyItHappens": "THREE.Vector3 objects maintain internal array storage [x, y, z] and also expose .x, .y, .z properties. When you create a Vector3 and then modify .x/.y/.z directly (instead of using .set() or .add() methods), you can corrupt the internal state. The physics code was written assuming velocity is a plain object {x, y, z}, but it's actually a THREE.Vector3 with special requirements.",
  "proposedFix": "In ShipPhysics.js constructor (line 38), initialize velocity as a plain object instead of THREE.Vector3:\n\nChange:\nthis.velocity = typeof THREE !== 'undefined' ? new THREE.Vector3(0, 0, 0) : { x: 0, y: 0, z: 0 };\n\nTo:\nthis.velocity = { x: 0, y: 0, z: 0 };\n\nThis ensures velocity is always a plain object that supports direct .x/.y/.z modification, which is what the physics code expects. The THREE.Vector3 initialization was a bug that conflicted with the physics update code's assumptions."
}
```

DECISION: root_cause_found